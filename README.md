<a name="readme-top"></a>

<details>
	<summary>Вопросы</summary>
	<ol>
		<li><a href="#l-value-%D0%B8-r-value">l-value и r-value</a></li>
		<li><a href="#nullptr-null-0">nullptr, null, 0</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">Алгоритм бинарного поиска</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%85%D0%B0%D1%80%D0%B0%D0%BA%D1%82%D0%B5%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B8">Алгоритм сортировки, основные характеристики</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%85%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Алгоритм хеширования</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8">Алгоритмы стандартной библиотеки</a></li>
		<li><a href="#%D0%B0%D0%BB%D1%84%D0%B0%D0%B2%D0%B8%D1%82-%D0%B8-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80">Алфавит и идентификатор</a></li>
		<li><a href="#%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9">Арифметика указателей</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4">АТД</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-c%D1%82%D0%B5%D0%BA-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «cтек» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%B4%D1%8D%D0%BA-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «дэк» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «массив» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «матрица» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «множество» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-%D1%81-%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «очередь с приоритетом» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «очередь» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BF%D0%BE%D0%BB%D0%B8%D0%BD%D0%BE%D0%BC-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «полином» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «словарь» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «строка» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «число» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">АТД и структура данных</a></li>
		<li><a href="#%D0%B1%D0%B5%D1%81%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5-%D1%86%D0%B8%D0%BA%D0%BB%D1%8B">Бесконечные циклы</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-library-%D0%B8-%D0%BA%D0%B0%D1%80%D0%BA%D0%B0%D1%81-framework">Библиотека (library) и каркас (framework)</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Библиотека динамическая</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Библиотека статическая</a></li>
		<li><a href="#%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D1%80%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2">Буферизация при использовании потоков</a></li>
		<li><a href="#%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2">Валидность итераторов</a></li>
		<li><a href="#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA">Ввод и вывод, обработка ошибок</a></li>
		<li><a href="#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0">Ввод и вывод, стандартная библиотека</a></li>
		<li><a href="#%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">Встроенный массив</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BD%D0%B5%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9">Вывод и ввод, неформатированный</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Вывод и ввод, позиционирование</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8">Вывод и ввод, потоки</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8">Вывод и ввод, файловые потоки</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9">Вывод и ввод, форматированный</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Выражение</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F---%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D1%8B-%D0%B8-%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Выражения - приоритеты и порядок вычисления</a></li>
		<li><a href="#%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0">Глобальные и локальные имена</a></li>
		<li><a href="#%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80">Деструктор</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B-%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">Диапазоны арифметических типов</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B-%D0%B8-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0%D0%B4-%D0%BD%D0%B8%D0%BC%D0%B8">Диапазоны и операции над ними</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E">Динамическое управление памятью</a></li>
		<li><a href="#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0%D0%BC-%D0%B2-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B5">Доступ к именам в пространстве</a></li>
		<li><a href="#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%87%D0%BB%D0%B5%D0%BD%D0%B0%D0%BC">Доступ к членам</a></li>
		<li><a href="#%D0%B4%D1%80%D1%83%D0%B7%D1%8C%D1%8F-friend">Друзья (friend)</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B---%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Заголовочные файлы - практика использования</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD-%D0%B4%D1%8B%D1%80%D1%8F%D0%B2%D1%8B%D1%85-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">Закон дырявых абстракций</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0">Замещение метода</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D1%82%D0%B8%D0%BF%D0%B0">Инвариант типа</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Инициализация</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B8-%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82">Инкремент и декремент</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Инстанциирование</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%B0">Инструкции выбора</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Инструкции управления</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%B2">Инструкции циклов</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F-%D1%81%D1%80%D0%B5%D0%B4%D0%B0-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">Интегрированная среда разработки</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B3%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D0%B8-%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D0%B8">Исключения, гарантии безопасности</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Исключения, обработка</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%BE%D0%B9-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8">Использование параметров командной строки</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0">Использование препроцессора</a></li>
		<li><a href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Итераторы (основные понятия, использование)</a></li>
		<li><a href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B0%D0%B4%D0%B0%D0%BF%D1%82%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5">Итераторы адаптирующие</a></li>
		<li><a href="#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D1%8B">Классы и экземпляры</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-extern">Ключевое слово extern</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-override">Ключевое слово override</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-template-%D0%B8-typename">Ключевое слово template и typename</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-this">Ключевое слово this</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-using">Ключевое слово using</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-virtual">Ключевое слово virtual</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2%D1%8B%D0%B5-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-%D0%B8-%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Кодовые таблицы и юникод</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F">Композиция</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C">Константность</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80">Конструктор</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Конструктор копирования</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D0%B2-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5">Контейнеры (в стандартной библиотеке)</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F">Контейнеры (осноные понятия)</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2">Копирование объектов</a></li>
		<li><a href="#%D0%BB%D0%BE%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Логирование</a></li>
		<li><a href="#%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81%D1%8B">Макросы</a></li>
		<li><a href="#%D0%BC%D0%B0%D0%BD%D0%B8%D0%BF%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Манипуляторы и их использование</a></li>
		<li><a href="#%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE">Машинное слово</a></li>
		<li><a href="#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4">Метод</a></li>
		<li><a href="#%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8">Модель памяти</a></li>
		<li><a href="#%D0%BD%D0%BE%D0%BB%D1%8C">Ноль</a></li>
		<li><a href="#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-scope">Область видимости (scope)</a></li>
		<li><a href="#%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Обобщенное программирование</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Обработка входных данных</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B">Обработка ошибок (методы)</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">Объект</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Объявление</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80">Оператор</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Оператор присваивания</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B---%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D1%8B">Операторы - приоритеты</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5">Операторы арифметические</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B1%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5">Операторы битовые</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0">Операторы вывода и ввода</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Операторы доступа</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5">Операторы логические</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F">Операторы сравнения</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%83%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B5---%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%B0%D1%8F-%D0%B8-%D0%BF%D0%BE%D1%81%D1%82%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%B0%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D1%8B">Операторы унарные - префиксная и постфиксная формы</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0">Операторы, перегрузка</a></li>
		<li><a href="#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Определение</a></li>
		<li><a href="#%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D1%87%D0%B8%D0%BA">Отладчик</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Память динамическая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Память статическая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%81%D1%82%D0%B5%D0%BA%D0%BE%D0%B2%D0%B0%D1%8F">Память стековая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B2-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5">Память, работа в стандартной библиотеке</a></li>
		<li><a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F">Переменная</a></li>
		<li><a href="#%D0%BF%D0%BE%D0%BB%D0%B5">Поле</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2">Порядок байтов</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5">Потоки стандартные</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5">Потоки строковые</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5">Потоки файловые</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D1%83">Программирование по контракту</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D1%8F%D1%89%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Производящая функция</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD-namespace">Пространства имен (namespace)</a></li>
		<li><a href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC-%D1%82%D0%B8%D0%BF%D0%B0">Псевдоним типа</a></li>
		<li><a href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D1%8B%D0%B5-%D1%87%D0%B8%D1%81%D0%BB%D0%B0">Псевдослучайные числа</a></li>
		<li><a href="#%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F">Раздельная компиляция</a></li>
		<li><a href="#%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F">Рекурсия</a></li>
		<li><a href="#%D1%81%2B%2B-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-%D1%81">С++ (общие сведения, отношение с с)</a></li>
		<li><a href="#%D1%81%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Связывание</a></li>
		<li><a href="#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Специализация</a></li>
		<li><a href="#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0">Ссылка</a></li>
		<li><a href="#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F">Статическая переменная</a></li>
		<li><a href="#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D1%87%D0%BB%D0%B5%D0%BD-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">Статический член (класса)</a></li>
		<li><a href="#%D1%81%D1%82%D0%B5%D0%BA-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2">Стек вызовов</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%B0%D0%B6%D0%B8-%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Стражи включения</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D1%81-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D0%B8-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Строки (с-строки) и литералы, обработка</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-std%3A%3Astring-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Строки std::string, обработка</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0">Структура</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Структура данных</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B3%D1%80%D0%B0%D1%84">Структура данных «граф»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">Структура данных «дерево»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6">Структура данных «кортеж»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">Структура данных «массив»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B4%D0%B2%D1%83%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9">Структура данных «список двусвязный»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BE%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9">Структура данных «список односвязный»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">Структура данных «хеш-таблица»</a></li>
		<li><a href="#%D1%82%D0%B5%D0%BA%D1%81%D1%82-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8">Текст программы, комментарии</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-pod">Тип pod</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-void">Тип void</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9">Тип вещественный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9">Тип встроенный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Тип данных</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85---%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%B0">Тип данных - принципы выбора</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9">Тип копируемый</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9">Тип логический</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Тип перечисление</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9">Тип символьный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8">Тип стандартной библиотеки</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%86%D0%B5%D0%BB%D1%8B%D0%B9">Тип целый</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D1%8B%D0%B5">Типов преобразования неявные</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%8F%D0%B2%D0%BD%D1%8B%D0%B5">Типов преобразования явные</a></li>
		<li><a href="#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C">Указатель</a></li>
		<li><a href="#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C-%D0%BD%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E">Указатель на функцию</a></li>
		<li><a href="#%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BE%D0%BC">Управление доступом</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%82%D0%BE%D1%80-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">Функтор (функциональный объект)</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Функция</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F---%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0">Функция - перегрузка</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F---%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Функция - передача параметров, возврат значения</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-main">Функция main</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD---%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B">Шаблон - параметры</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Шаблонная функция</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF">Шаблонный тип</a></li>
		<li><a href="#abi">ABI</a></li>
		<li><a href="#pimpl">PIMPL</a></li>
		<li><a href="#raii">RAII</a></li>
		<li><a href="#ref-qualifiers-for-%2Athis">Ref-qualifiers for *this</a></li>
		<li><a href="#singleton">Singleton</a></li>
		<li><a href="#std%3A%3Abitset">std::bitset</a></li>
		<li><a href="#std%3A%3Aforward">std::forward</a></li>
		<li><a href="#std%3A%3Amove">std::move</a></li>
		<li><a href="#std%3A%3Ashared_ptr">std::shared_ptr</a></li>
		<li><a href="#std%3A%3Aunique_ptr">std::unique_ptr</a></li>
		<li><a href="#std%3A%3Aweak_ptr">std::weak_ptr</a></li>
		<li><a href="#%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BB%D0%B0%D1%81%D1%81">Абстрактный класс</a></li>
		<li><a href="#%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">Виртуальный вызов, виртуальные функции</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC">Динамический полиморфизм</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80%D1%8B">Зависимости, пакетные менеджеры</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BC%D0%B5%D1%80%D1%8B-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8">Замеры времени</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-final">Ключевое слово final</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-mutable">Ключевое слово mutable</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B9">Конструктор перемещающий</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-generic">Лямбды, generic</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82">Лямбды, захват</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Лямбды, использование</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Лямбды, общие сведения</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">Лямбды, хранение</a></li>
		<li><a href="#%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Множественное наследование</a></li>
		<li><a href="#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5">Наследование (в языке)</a></li>
		<li><a href="#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Наследование (ограничение доступа)</a></li>
		<li><a href="#%D0%BE%D0%BE%D0%BF-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B">Ооп, базовые принципы</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%87%D0%BB%D0%B5%D0%BD%D1%83-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%22">Оператор "доступ к члену через указатель"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%B0%D1%8F%22">Оператор "запятая"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-%D1%82%D0%B8%D0%BF%D1%83%22">Оператор "приведение к типу"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D1%80%D0%B0%D0%B7%D1%8B%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%22">Оператор "разыменование"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B9">Оператор присваивания перемещающий</a></li>
		<li><a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5">Перемещение</a></li>
		<li><a href="#%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9-%D0%BA%D1%80%D0%B8%D1%82%D0%B5%D1%80%D0%B8%D0%B9">Подстановочный критерий</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Выравнивание</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Предупреждения</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B0%D1%8E%D1%89%D0%B5%D0%B5">Преобразование повышающее</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%B6%D0%B0%D1%8E%D1%89%D0%B5%D0%B5">Преобразование понижающее</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-bit_cast">Приведение типа bit_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-const_cast">Приведение типа const_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-dynamic_cast">Приведение типа dynamic_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-reinterpret_cast">Приведение типа reinterpret_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-static_cast">Приведение типа static_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Производные объекты, конструирование и уничтожение</a></li>
		<li><a href="#%D0%BF%D1%80%D1%8F%D0%BC%D0%B0%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0">Прямая передача</a></li>
		<li><a href="#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0%D1%8F">Ссылка (правая)</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Шаблон, специализация</a></li>
	</ol>
</details>

<hr style="width:25%;text-align:left;margin-left:0">

## l-value и r-value

`l-value` - это выражение, которое имеет идентификатор и адрес в памяти, куда можно присвоить значение.

`r-value` - это выражение, которое не имеет адреса в памяти и часто используется как значение.

### Примеры
```C++
int x = 5; // x - l-value, 5 - r-value
```

<hr style="width:25%;text-align:left;margin-left:0">

## nullptr, NULL, 0

`nullptr` - введен в стандарте C++11 и представляет собой безопасную замену для `NULL` и `0` в указателях. `nullptr` имеет тип `std::nullptr_t` и может быть присвоен любому указателю.

`0` - также используется для представления нулевого указателя.

`NULL` - это макрос, обычно определенный как #define NULL 0, который используется для представления нулевого указателя (наследство из C -> не используем).

В C++11 и более поздних стандартах рекомендуется использовать `nullptr` вместо `NULL` и `0`, так как `nullptr` имеет явный тип и предотвращает некоторые ошибки, связанные с неправильным использованием нулевых указателей.

### Примеры
```C++
int* ptr1 = nullptr;
int* ptr2 = NULL;
int* ptr3 = 0;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм бинарного поиска

Бинарный поиск — это эффективный алгоритм поиска, который используется для нахождения позиции заданного элемента в отсортированном массиве. Принцип работы бинарного поиска заключается в последовательном делении массива на две части и сравнении искомого значения со значением элемента в середине массива.

Преимущества бинарного поиска:
* Высокая эффективность: Время выполнения бинарного поиска — `O(log n)`, где `n` — количество элементов в массиве.
* Простота реализации: Легко реализовать и отладить.

Ограничения:
* Требует отсортированного массива.
* Подходит только для последовательного доступа: Не подходит для структур данных с произвольным доступом, таких как связные списки.

Сложность по времени: `O(log n)`

Сложность по памяти: `O(1)`

### Примеры
```C++
std::vector<int> vec = { 1, 3, 5, 7, 9, 11, 13 }; // Вектор уже отсортирован
int target = 7; // искомое значение
std::binary_search(vec.begin(), vec.end(), target) // true - найден, false - нет
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм сортировки, основные характеристики

Алгоритмы сортировки позволяют упорядочить данные для эффективного доступа и обработки. Основные характеристики алгоритмов сортировки включают сложность по времени и памяти, стабильность и адаптивность.

### Примеры
Пузырьковая сортировка (Bubble Sort)
* Сложность по времени: `O(n^2)` в худшем и среднем случае, `O(n)` в лучшем случае (если массив уже отсортирован).
* Сложность по памяти: `O(1)`, так как не требует дополнительной памяти.
* Стабильность: Стабильный (не меняет порядок равных элементов).
* Адаптивность: Адаптивен (способность алгоритма работать быстрее на частично отсортированных данных).

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритм хеширования

Это функция, преобразующая входные данные произвольной длины в строку фиксированной длины, часто называемую хеш-кодом. Полученный хеш обычно имеет меньший размер, чем исходные данные.

Хеширование используется во многих областях информационной безопасности, включая проверку целостности данных и аутентификацию. Алгоритмы хеширования позволяют распознавать изменённые данные, они применяются в базах данных для более эффективного доступа к данным, в цифровых подписях, блокчейнах и хранении паролей.

Свойства:
* Детерминированность: одни и те же входные данные всегда приводят к тому же хеш-коду.
* Быстрое вычисление: хеш можно вычислить относительно быстро для любого объема входных данных.
* Эффект лавины: небольшое изменение входных данных вызывает существенное изменение результата хеширования.
* Необратимость: невозможно восстановить исходные данные по их хеш-коду.
* Стойкость к коллизиям: сложность нахождения второго входного значения, которое имеет такой же хэш, как и данное входное значение (слабая/сильная).

### Примеры
```C++
std::unordered_map<std::string, int> umap;

// Вставка элементов в unordered_map
umap["apple"] = 2;
umap["banana"] = 4;
umap["orange"] = 3;

// Альтернативный способ вставки с использованием метода insert
umap.insert({ "pear", 5 });
```

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритмы стандартной библиотеки

Стандартная библиотека - коллекция классов, функций, макросов и констант.

Находятся в `<algorithm>`.

Основные категории алгоритмов:
* Алгоритмы поиска и проверки.
* Алгоритмы сортировки и упорядочивания.
* Алгоритмы модификации.
* Алгоритмы копирования и перемещения.
* Алгоритмы генерации и удаления.
* Алгоритмы численных операций.

### Примеры
```C++
int x = 1;
int y = 2;
std::min(x, y); // 1
std::max(x, y); // 2

std::vector<int> vec = { 1, 2, 3, 4, 5 };
std::find(vec.begin(), vec.end(), 3); // поиск индекса эллемента '3'

std::binary_search(vec.begin(), vec.end(), 3); // true - '3' найдено, false - '3' не найдено

std::vector<int> vec = {5, 3, 1, 4, 2};
std::sort(vec.begin(), vec.end()); // vec = { 1, 2, 3, 4, 5 }

std::reverse(vec.begin(), vec.end()); // vec = { 5, 4, 3, 2, 1 }

std::replace(vec.begin(), vec.end(), 1, 9); // vec = { 5, 4, 3, 2, 9 }

std::vector<int> vec_copy(5);
std::copy(vec.begin(), vec.end(), vec_copy.begin()); // vec_copy = { 5, 4, 3, 2, 9 }

std::vector<int> vec_move(5);
std::move(vec_copy.begin(), vec_copy.end(), vec_move.begin()); // vec_move = { 5, 4, 3, 2, 9 } vec_copy = { }
```

<hr style="width:25%;text-align:left;margin-left:0">

##  Алфавит и идентификатор

Алфавит C++ состоит из следующих символов:

1. Буквы:
* Заглавные латинские буквы: `A-Z`.
* Строчные латинские буквы: `a-z`.
* Цифры: `0-9`.

2. Специальные символы:
* Символы пунктуации: `+`, `-`, `*`, `/`, `%`, `=`, `&`, `|`, `!`, `^`, `~`, `<`, `>`, `?`, `:`, `;`, `,`, `.`, `@`, `#`, `$`, `_`
* Скобки и операторы: `()`, `{}`, `[]`, `::`, `->`, `.`

3. Пробелы и управляющие символы:
* Пробел, табуляция и другие символы управления, такие как `\n` (новая строка), `\t` (табуляция) и т.д.
* Идентификаторы — это имена, которые программист присваивает переменным, функциям, классам, объектам и другим элементам программы. Правила именования идентификаторов в C++:

Начало идентификатора:
* Должен начинаться с буквы (заглавной или строчной) или символа подчеркивания `_`
* Не может начинаться с цифры.

Содержимое идентификатора:
* Может содержать буквы, цифры и символы подчеркивания.
* Пробелы и специальные символы (кроме `_`) не допускаются.

Регистр имеет значение:
* C++ различает идентификаторы, записанные в разном регистре. Например, `Variable` и `variable` считаются разными идентификаторами.

Ключевые слова:
* Идентификаторы не могут совпадать с ключевыми словами языка C++ (например, `int`, `class`, `return` и т.д.).

Стиль именования:
* Стиль именования может следовать соглашениям, принятым в проекте или команде. Например, CamelCase, snake_case и т.д.

### Примеры
```C++
int myVariable;       // допустимый идентификатор
int _my_variable;     // допустимый идентификатор
int variable2;        // допустимый идентификатор
int Variable;         // допустимый идентификатор, отличается от "variable"
int 2variable;        // недопустимый идентификатор, начинается с цифры
int my-variable;      // недопустимый идентификатор, содержит дефис
int int;              // недопустимый идентификатор, совпадает с ключевым словом
```

<hr style="width:25%;text-align:left;margin-left:0">

## Арифметика указателей

К указателю можно прибавлять число, тогда он станет указывать на следующий элемент(если он указывал на элемент массива). Если указатель вышел за пределы массива, то результат разыменования не определён. Можно вычитать указатель из указателя в пределах одного массива, результатом будет количество элементов между ними.

### Примеры
```C++
int arr[] = { 1, 2, 3, 4, 5 };
int *ptr = arr; // Указатель на начало массива arr

std::cout << "Element 1: " << *ptr << std::endl; // Вывод первого элемента

++ptr; // Перемещение указателя на следующий элемент
std::cout << "Element 2: " << *ptr << std::endl; // Вывод второго элемента

ptr += 2; // Перемещение указателя на два элемента вперед
std::cout << "Element 4: " << *ptr << std::endl; // Вывод четвертого элемента

--ptr; // Перемещение указателя на 1 элемент назад
std::cout << "Element 3: " << *ptr << std::endl; // Вывод третьего элемента
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД

Абстрактный Тип Данных - интерфейс, описывающий набор операций над типом данных, но не то как они реализованы(логику использования). Операции, описанные в любом АТД - создание, уничтожение, копирование. АТД скрывает детали реализации, лишь предоставляя интерфейс.

### Примеры
* Стек
* Очередь
* Двусвязный список

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «cтек» и варианты реализации

Абстрактный тип данных "стек" реализует структуру данных с наиболее последним приходом, первым на выход (LIFO - Last-In, First-Out). Элементы добавляются на вершину стека и удаляются с вершины.

Основные операции, которые определяют интерфейс стека, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `push` - добавление элемента в конец стека.
* `pop` - удаление и возвращение элемента с конца стека.
* `top` или `peek` - возвращение элемента с конца стека без удаления.
* `isEmpty` - проверка, пуст ли стек.
* `size` - получение числа элементов в стеке.

Реализация на основе массива и связанного списка.
В стандартной библиотеке реализован на deque(дэк) и представлен в виде `std::stack<T>`.

<hr style="width:25%;text-align:left;margin-left:0">АТД «дэк» и варианты реализации

## АТД «дэк» и варианты реализации

Двусвязная очередь - это абстрактный тип данных, представляет собой структуру данных, которая поддерживает добавление и удаление элементов с обоих концов.

Реализация на основе массива и двусвязанного списка.

Основные операции, которые определяют интерфейс дэка, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `push_back` - добавление элемента в конец дэка.
* `push_front` - добавление элемента в начало дэка.
* `pop_back` - удаление и возвращение элемента с конца дэка.
* `pop_front` - удаление и возвращение элемента с начала дэка.
* `top` или `peek` - возвращение элемента с конца дэка без удаления.
* `isEmpty` - проверка, пуст ли дэк.
* `size` - получение числа элементов в дэке.

В стандартной библиотеке - `std::deque<T>`.

### Примеры
```C++
std::deque<int> myDeque;

myDeque.push_back(10); // Добавление в конец
myDeque.push_front(5); // Добавление в начало

// Доступ к элементам "дэка"
std::cout << "Front element: " << myDeque.front() << std::endl; // '5'
std::cout << "Back element: " << myDeque.back() << std::endl; // '10'

myDeque.pop_front(); // Удаление из начала
myDeque.pop_back(); // Удаление из конца
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «массив» и варианты реализации

Типы:
* Статический массив: Фиксированный размер, быстрый доступ к элементам и вставка.
* Динамический массив: Размер меняется во время выполнения программы, быстрый доступ к элементам, но вставка при расширении занимает дольше времени.

Основные операции, которые определяют интерфейс массива, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `empty` - проверка, пуст ли массив.
* `size` - получение числа элементов в массивe.

В стандартной библиотеке представлены в виде `std::array<T>` и `std::vector<T>`.

### Примеры
```C++
std::vector<int> vec;

// Добавляем элементы в конец вектора
vec.push_back(1);
vec.push_back(2);

// Выводим элементы вектора
for (int i = 0; i < vec.size(); ++i) {
	std::cout << "Element " << i << ": " << vec[i] << std::endl;
}

vec[1] = 5; // Изменяем значение элемента по индексу 1 на '5'

// --------------------------------------------------------------

std::array<int, 5> arr = { 1, 2, 3, 4, 5 };

// Выводим элементы массива
std::cout << "Array elements:" << std::endl;
for (int i = 0; i < arr.size(); ++i) {
	std::cout << "Element " << i << ": " << arr[i] << std::endl;
}

arr[1] = 6; // Изменяем значение элемента по индексу 1 на '6'
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «матрица» и варианты реализации

Это абстрактный тип данных, описывающий набор операций над элементами, расположенными в виде таблицы: создание, уничтожение, копирование, доступ к элементу по индексу, получение количества столбцов, получение количества строк.

Можно реализовать через массив с приведенным индексом, или массивы одинаковой длины в другом массиве.

### Примеры
```C++
std::vector<std::vector<int>> mat = {
	{ 5, 8, 2 },
	{ 8, 3, 1 },
	{ 5, 3, 9 }
};

std::array<std::array<int, 3>, 3> matrix = {
	{ 5, 8, 2 },
	{ 8, 3, 1 },
	{ 5, 3, 9 }
};
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «множество» и варианты реализации

Это структура данных, которая содержит уникальные элементы без какого-либо порядка.

Можно реализовать через массив с проверкой на дубликаты или хэш-функцию.

Основные операции, которые определяют интерфейс множества, включают:
* `insert` - вставка эллемента во множество.

В стандартной библиотеке представлена в виде `std::set<T>`.

### Примеры
```C++
std::set<int> mySet;

// Вставляем элементы в множество
mySet.insert(3);
mySet.insert(1);
mySet.insert(5);
mySet.insert(2);
mySet.insert(1); // Этот элемент не будет добавлен, так как '1' уже есть во множестве
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «очередь с приоритетом» и варианты реализации

Это структура данных, которая хранит элементы с определенным приоритетом. Элемент с более высоким приоритетом извлекается раньше, чем элементы с более низким приоритетом.

Можно реализовать через массив, вставляя эллемент в определенное место.

В стандартной библиотеке представлена в виде `std::priority_queue<T>`.

### Примеры
```C++
std::priority_queue<int> pq;

pq.push(30); // низкий приоритет
pq.push(100); // высокий приоритет
pq.push(50); // средний приоритет

while (!pq.empty()) {
	std::cout << pq.top() << " ";
	pq.pop();
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «очередь» и варианты реализации

Представляет собой структуру данных, работающую по принципу FIFO (First In, First Out), что означает, что первый элемент, добавленный в очередь, будет первым извлечен из неё.

Может быть реализована несколькими способами: с использованием массивов, связных списков.

Основные операции, которые определяют интерфейс очереди, включают:
* `push` - добавление элемента в конец очереди.
* `pop` - удаление и возвращение элемента с конца очереди.
* `empty` - проверка, пуста ли очередь.
* `size` - получение числа элементов в очереди.

В стандартной библиотеке представлена в виде `std::queue<T>`.

### Примеры
```C++
std::queue<int> q;
 
q.push(0); // q = 0
q.push(1); // q = 0 1
q.push(2); // q = 0 1 2
q.push(3); // q = 0 1 2 3

q.size() // 4

q.pop(); // удаляет первый эллемент 0

q.size() // 3
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «полином» и варианты реализации

Это абстрактный тип данных, описывающий операции над многочленом.

Можно реализовать через массив, хранящий коэффициенты.

Основные операции, которые определяют интерфейс полинома, включают:
* Сложение полиномов.
* Доступ к коэффициенту по индексу.
* Умножение на число.

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «словарь» и варианты реализации

Представляет собой структуру данных, описывающую операции над набором пар типов, где один из типов является ключём, а другой - значением.

Может быть реализован несколькими способами: с использованием хэш-функции и деревом.

Основные операции, которые определяют словарь очереди, включают:
* `operator[]` - получение/запись эллемента по ключу.
* `insert` - добавление элемента в словарь.
* `erase` - удаление и элемента по ключу.
* `empty` - проверка, пустой ли словарь.
* `size` - получение числа элементов в словаре.

В стандартной библиотеке представлены в виде `std::map<T>`(сбалансированное красно-черное дерево) и `std::unordered_map<T>`(хэш-функция).

### Примеры
```C++
std::map<std::string, int> myMap;

// Добавляем элементы в map
myMap["apple"] = 5;
myMap["banana"] = 3;
myMap["orange"] = 7;

myMap.erase("apple"); // Удаляем элемент из map

// ------------------------------------------------

std::unordered_map<std::string, int> myUnorderedMap;

// Добавляем элементы в unordered_map
myUnorderedMap["apple"] = 5;
myUnorderedMap["banana"] = 3;
myUnorderedMap["orange"] = 7;

myUnorderedMap.erase("apple"); // Удаляем элемент из unordered_map
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «строка» и варианты реализации

Представляет собой структуру данных, описывающую операции над последовательностью символом.

Может быть реализована несколькими способами: массивом из символов(char'ов).

Основные операции, которые определяют строку очереди, включают:
* `operator[]` - получение/запись символа по индексу.
* `erase` - удаление и символа по индексу.
* `empty` - проверка, пустая ли строка.
* `length` - получение числа символов в строке.

В стандартной библиотеке представлена в виде `std::string`.

### Примеры
```C++
std::string str = "Hello";

str.length() // 5

str[0]; // 'H'

str.erase(0) // str = "ello"

str.empty() // false
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «число» и варианты реализации

Представляет собой математическую абстракцию чисел и операции над ними.

В рамках программирования АТД «число» может быть представлен различными способами в зависимости от требований к точности и диапазону значений. 

Основные операции, которые определяют число очереди, включают:
* Операторы арифметических операций.
* Операторы сравнения.

В C++ представлены в виде `int`, `float`, `double` и т.д.

### Примеры
```C++
int a = 10;
float b = 3.14;
double c = 354654.34686796345;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Инстанциирование

Генерация объявления функции или типа по шаблону и его аргументам. Осуществляется во время компиляции.

### Примеры
```C++
// Объявление шаблона функции
template <typename T>
T add(T a, T b)
{
    return a + b;
}

// Объявление шаблона класса
template <typename T>
class Box
{
public:
    Box(T v) : value(v) {}

private:
    T value;
};

int main()
{
    // Инстанциирование шаблонной функции с типом int
    int intResult = add<int>(3, 4);
    
    // Инстанциирование шаблонного класса с типом int
    Box<int> intBox(123);

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Прямая передача

Прямая передача - передача аргументов без лишнего копирования/перемещения. Используется в обёрточных функциях для передачи аргументов. Реализуется при помощи функции `std::forward<T>`, которая передает значение сохраняя его тип(lvalue/rvalue). 

### Примеры
```C++
#include <utility> // Для std::forward

// Функция process для обработки строки rvalue
void process(std::string&& str)
{
    std::cout << "Обработка rvalue строки: " << str << std::endl;
}

// Функция process для обработки строки lvalue
void process(const std::string& str)
{
    std::cout << "Обработка lvalue строки: " << str << std::endl;
}

// Шаблонная функция wrapper с универсальной ссылкой
template <typename T>
void wrapper(T&& arg)
{
    // Передаем аргумент в функцию process с помощью std::forward,
    // чтобы сохранить его тип (lvalue или rvalue)
    process(std::forward<T>(arg));
}

int main()
{
    std::string s = "Hello";
    wrapper(s);            // Вызов с lvalue
    wrapper(std::move(s)); // Вызов с rvalue

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Ссылка (правая)

Правая ссылка(rvalue) - ссылка на временный объект. Используется для избежания ненужного копирования(семантика перемещения), так как позволяет перемещать ресурсы одного объекта в другой.

### Примеры
```C++
std::string str1 = "Hello, World!";
std::cout << "str1: " << str1 << std::endl;

// Перемещаем содержимое str1 в str2
std::string str2 = std::move(str1);
std::cout << "После перемещения:" << std::endl;
std::cout << "str1: " << str1 << std::endl;
std::cout << "str2: " << str2 << std::endl;

//Вывод:
//str1: Hello, World!
//После перемещения:
//str1: 
//str2: Hello, World!
```

<hr style="width:25%;text-align:left;margin-left:0">

## Шаблон, специализация

Шаблон - это конструкция, которая на этапе компиляции создает обычный тип или функцию на основе аргументов. Используется когда поведение функции для многочисленного набора разных типов одинаково или похоже, вместо того чтобы определять много перегрузок.

Специализация - определение функций или типов для специального набора аргументов.

### Примеры
```C++
// Объявление шаблона функции
template <typename T>
T add(T a, T b)
{
    return a + b;
}

//специализация шаблона функции
template <>
std::string add<std::string>(std::string a, std::string b)
{
    return a.append(b);
}

// Объявление шаблона класса
template <typename T>
class Box
{
public:
    Box(T v) : value(v) {}

private:
    T value;
};
```

<hr style="width:25%;text-align:left;margin-left:0">

<p align="right">(<a href="#readme-top">Вернуться в начало</a>)</p>