<a name="readme-top"></a>

<details>
 <summary>Вопросы</summary>
  <ol>
   <li><a href="#l-value-и-r-value">l-value и r-value</a></li>
   <li><a href="#nullptr-null-0">nullptr, NULL, 0</a></li>
   <li><a href="#алгоритм-бинарного-поиска">Алгоритм бинарного поиска</a></li>
  </ol>
</details>

<hr style="width:25%;text-align:left;margin-left:0">

## l-value и r-value

l-value - это выражение, которое имеет идентификатор и адрес в памяти, куда можно присвоить значение.
r-value - это выражение, которое не имеет адреса в памяти и часто используется как значение.

### Пример
```C++
int x = 5; // x - l-value, 5 - r-value
```

<hr style="width:25%;text-align:left;margin-left:0">

## nullptr, NULL, 0

nullptr - введен в стандарте C++11 и представляет собой безопасную замену для NULL и 0 в указателях. nullptr имеет тип std::nullptr_t и может быть присвоен любому указателю.
0 - также используется для представления нулевого указателя.
NULL - это макрос, обычно определенный как #define NULL 0, который используется для представления нулевого указателя (наследство из C -> не используем).
В C++11 и более поздних стандартах рекомендуется использовать nullptr вместо NULL и 0, так как nullptr имеет явный тип и предотвращает некоторые ошибки, связанные с неправильным использованием нулевых указателей.

### Пример
```C++
int* ptr1 = nullptr;
int* ptr2 = NULL;
int* ptr3 = 0;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм бинарного поиска

Бинарный поиск — это эффективный алгоритм поиска, который используется для нахождения позиции заданного элемента в отсортированном массиве. Принцип работы бинарного поиска заключается в последовательном делении массива на две части и сравнении искомого значения со значением элемента в середине массива.

Преимущества бинарного поиска:
* Высокая эффективность: Время выполнения бинарного поиска — O(log n), где n — количество элементов в массиве.
* Простота реализации: Легко реализовать и отладить.

Ограничения:
* Требует отсортированного массива.
* Подходит только для последовательного доступа: Не подходит для структур данных с произвольным доступом, таких как связные списки.

Сложность по времени: O(log n)

Сложность по памяти: O(1)

### Пример
```C++
std::vector<int> vec = { 1, 3, 5, 7, 9, 11, 13 }; // Вектор уже отсортирован
int target = 7; //искомое значение
std::binary_search(vec.begin(), vec.end(), target) //true - найден, false - нет
```

<hr style="width:25%;text-align:left;margin-left:0">

<p align="right">(<a href="#readme-top">вернуться в начало</a>)</p>
