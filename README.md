<a name="readme-top"></a>

<details>
 <summary>Вопросы</summary>
  <ol>
   <li><a href="#l-value-и-r-value">l-value и r-value</a></li>
   <li><a href="#nullptr-null-0">nullptr, NULL, 0</a></li>
   <li><a href="#алгоритм-бинарного-поиска">Алгоритм бинарного поиска</a></li>
   <li><a href="#алгоритм-сортировки-основные-характеристики">Алгоритм сортировки, основные характеристики</a></li>
   <li><a href="#алгоритм-хеширования">Алгоритм хеширования</a></li>
  </ol>
</details>

<hr style="width:25%;text-align:left;margin-left:0">

## l-value и r-value

l-value - это выражение, которое имеет идентификатор и адрес в памяти, куда можно присвоить значение.

r-value - это выражение, которое не имеет адреса в памяти и часто используется как значение.

### Пример
```C++
int x = 5; // x - l-value, 5 - r-value
```

<hr style="width:25%;text-align:left;margin-left:0">

## nullptr, NULL, 0

nullptr - введен в стандарте C++11 и представляет собой безопасную замену для NULL и 0 в указателях. nullptr имеет тип std::nullptr_t и может быть присвоен любому указателю.

0 - также используется для представления нулевого указателя.

NULL - это макрос, обычно определенный как #define NULL 0, который используется для представления нулевого указателя (наследство из C -> не используем).

В C++11 и более поздних стандартах рекомендуется использовать nullptr вместо NULL и 0, так как nullptr имеет явный тип и предотвращает некоторые ошибки, связанные с неправильным использованием нулевых указателей.

### Пример
```C++
int* ptr1 = nullptr;
int* ptr2 = NULL;
int* ptr3 = 0;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм бинарного поиска

Бинарный поиск — это эффективный алгоритм поиска, который используется для нахождения позиции заданного элемента в отсортированном массиве. Принцип работы бинарного поиска заключается в последовательном делении массива на две части и сравнении искомого значения со значением элемента в середине массива.

Преимущества бинарного поиска:
* Высокая эффективность: Время выполнения бинарного поиска — O(log n), где n — количество элементов в массиве.
* Простота реализации: Легко реализовать и отладить.

Ограничения:
* Требует отсортированного массива.
* Подходит только для последовательного доступа: Не подходит для структур данных с произвольным доступом, таких как связные списки.

Сложность по времени: O(log n)

Сложность по памяти: O(1)

### Пример
```C++
std::vector<int> vec = { 1, 3, 5, 7, 9, 11, 13 }; // Вектор уже отсортирован
int target = 7; // искомое значение
std::binary_search(vec.begin(), vec.end(), target) // true - найден, false - нет
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм сортировки, основные характеристики

Алгоритмы сортировки позволяют упорядочить данные для эффективного доступа и обработки. Основные характеристики алгоритмов сортировки включают сложность по времени и памяти, стабильность и адаптивность.

### Пример
Пузырьковая сортировка (Bubble Sort)
* Сложность по времени: O(n^2) в худшем и среднем случае, O(n) в лучшем случае (если массив уже отсортирован).
* Сложность по памяти: O(1), так как не требует дополнительной памяти.
* Стабильность: Стабильный (не меняет порядок равных элементов).
* Адаптивность: Адаптивен (способность алгоритма работать быстрее на частично отсортированных данных).

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритм хеширования

Это функция, преобразующая входные данные произвольной длины в строку фиксированной длины, часто называемую хеш-кодом. Полученный хеш обычно имеет меньший размер, чем исходные данные.

Хеширование используется во многих областях информационной безопасности, включая проверку целостности данных и аутентификацию. Алгоритмы хеширования позволяют распознавать изменённые данные, они применяются в базах данных для более эффективного доступа к данным, в цифровых подписях, блокчейнах и хранении паролей.

Свойства:
* Детерминированность: одни и те же входные данные всегда приводят к тому же хеш-коду.
* Быстрое вычисление: хеш можно вычислить относительно быстро для любого объема входных данных.
* Эффект лавины: небольшое изменение входных данных вызывает существенное изменение результата хеширования.
* Необратимость: невозможно восстановить исходные данные по их хеш-коду.
* Стойкость к коллизиям: сложность нахождения второго входного значения, которое имеет такой же хэш, как и данное входное значение (слабая/сильная).

### Пример
```C++
std::unordered_map<std::string, int> umap;

// Вставка элементов в unordered_map
umap["apple"] = 2;
umap["banana"] = 4;
umap["orange"] = 3;

// Альтернативный способ вставки с использованием метода insert
umap.insert({ "pear", 5 });
```

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритмы стандартной библиотеки

Стандартная библиотека - коллекция классов, функций, макросов и констант.

Находятся в <algorithm>.

Основные категории алгоритмов:
* Алгоритмы поиска и проверки.
* Алгоритмы сортировки и упорядочивания.
* Алгоритмы модификации.
* Алгоритмы копирования и перемещения.
* Алгоритмы генерации и удаления.
* Алгоритмы численных операций.

### Примеры
```C++
std::min(x, y)
std::max(x, y)

std::vector<int> vec = { 1, 2, 3, 4, 5 };
auto it = std::find(vec.begin(), vec.end(), 3); // поиск индекса эллемента 3

bool found = std::binary_search(vec.begin(), vec.end(), 3); // true - 3 найдено, false - 3 не найдено

std::vector<int> vec = {5, 3, 1, 4, 2};
std::sort(vec.begin(), vec.end()); // vec = { 1, 2, 3, 4, 5 }

std::reverse(vec.begin(), vec.end()); // vec = { 5, 4, 3, 2, 1 }

std::replace(vec.begin(), vec.end(), 1, 9); // vec = { 5, 4, 3, 2, 9 }

std::vector<int> vec_copy(5);
std::copy(vec.begin(), vec.end(), vec_copy.begin()); // vec_copy = { 5, 4, 3, 2, 9 }

std::vector<int> vec_move(5);
std::move(vec_copy.begin(), vec_copy.end(), vec_move.begin()); // vec_move = { 5, 4, 3, 2, 9 } vec_copy = { }
```

<hr style="width:25%;text-align:left;margin-left:0">


<p align="right">(<a href="#readme-top">Вернуться в начало</a>)</p>
