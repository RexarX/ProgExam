<a name="readme-top"></a>

<details>
	<summary>Вопросы</summary>
	<ol>
		<li><a href="#l-value-%D0%B8-r-value">l-value и r-value</a></li>
		<li><a href="#nullptr-null-0">nullptr, null, 0</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">Алгоритм бинарного поиска</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%85%D0%B0%D1%80%D0%B0%D0%BA%D1%82%D0%B5%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B8">Алгоритм сортировки, основные характеристики</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%85%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Алгоритм хеширования</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8">Алгоритмы стандартной библиотеки</a></li>
		<li><a href="#%D0%B0%D0%BB%D1%84%D0%B0%D0%B2%D0%B8%D1%82-%D0%B8-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80">Алфавит и идентификатор</a></li>
		<li><a href="#%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9">Арифметика указателей</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4">АТД</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-c%D1%82%D0%B5%D0%BA-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «cтек» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%B4%D1%8D%D0%BA-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «дэк» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «массив» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «матрица» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «множество» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-%D1%81-%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «очередь с приоритетом» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «очередь» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BF%D0%BE%D0%BB%D0%B8%D0%BD%D0%BE%D0%BC-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «полином» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «словарь» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «строка» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «число» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">АТД и структура данных</a></li>
		<li><a href="#%D0%B1%D0%B5%D1%81%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5-%D1%86%D0%B8%D0%BA%D0%BB%D1%8B">Бесконечные циклы</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-library-%D0%B8-%D0%BA%D0%B0%D1%80%D0%BA%D0%B0%D1%81-framework">Библиотека (library) и каркас (framework)</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Библиотека динамическая</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Библиотека статическая</a></li>
		<li><a href="#%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D1%80%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2">Буферизация при использовании потоков</a></li>
		<li><a href="#%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2">Валидность итераторов</a></li>
		<li><a href="#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA">Ввод и вывод, обработка ошибок</a></li>
		<li><a href="#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0">Ввод и вывод, стандартная библиотека</a></li>
		<li><a href="#%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">Встроенный массив</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BD%D0%B5%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9">Вывод и ввод, неформатированный</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Вывод и ввод, позиционирование</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8">Вывод и ввод, потоки</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8">Вывод и ввод, файловые потоки</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9">Вывод и ввод, форматированный</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Выражение</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F---%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D1%8B-%D0%B8-%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Выражения - приоритеты и порядок вычисления</a></li>
		<li><a href="#%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0">Глобальные и локальные имена</a></li>
		<li><a href="#%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80">Деструктор</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B-%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">Диапазоны арифметических типов</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B-%D0%B8-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0%D0%B4-%D0%BD%D0%B8%D0%BC%D0%B8">Диапазоны и операции над ними</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E">Динамическое управление памятью</a></li>
		<li><a href="#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0%D0%BC-%D0%B2-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B5">Доступ к именам в пространстве</a></li>
		<li><a href="#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%87%D0%BB%D0%B5%D0%BD%D0%B0%D0%BC">Доступ к членам</a></li>
		<li><a href="#%D0%B4%D1%80%D1%83%D0%B7%D1%8C%D1%8F-friend">Друзья (friend)</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B---%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Заголовочные файлы - практика использования</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD-%D0%B4%D1%8B%D1%80%D1%8F%D0%B2%D1%8B%D1%85-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">Закон дырявых абстракций</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0">Замещение метода</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D1%82%D0%B8%D0%BF%D0%B0">Инвариант типа</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Инициализация</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B8-%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82">Инкремент и декремент</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Инстанциирование</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%B0">Инструкции выбора</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Инструкции управления</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%B2">Инструкции циклов</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F-%D1%81%D1%80%D0%B5%D0%B4%D0%B0-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">Интегрированная среда разработки</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B3%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D0%B8-%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D0%B8">Исключения, гарантии безопасности</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Исключения, обработка</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%BE%D0%B9-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8">Использование параметров командной строки</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0">Использование препроцессора</a></li>
		<li><a href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Итераторы (основные понятия, использование)</a></li>
		<li><a href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B0%D0%B4%D0%B0%D0%BF%D1%82%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5">Итераторы адаптирующие</a></li>
		<li><a href="#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D1%8B">Классы и экземпляры</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-extern">Ключевое слово extern</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-override">Ключевое слово override</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-template-%D0%B8-typename">Ключевое слово template и typename</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-this">Ключевое слово this</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-using">Ключевое слово using</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-virtual">Ключевое слово virtual</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2%D1%8B%D0%B5-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-%D0%B8-%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Кодовые таблицы и юникод</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F">Композиция</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C">Константность</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80">Конструктор</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Конструктор копирования</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D0%B2-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5">Контейнеры (в стандартной библиотеке)</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F">Контейнеры (осноные понятия)</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2">Копирование объектов</a></li>
		<li><a href="#%D0%BB%D0%BE%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Логирование</a></li>
		<li><a href="#%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81%D1%8B">Макросы</a></li>
		<li><a href="#%D0%BC%D0%B0%D0%BD%D0%B8%D0%BF%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Манипуляторы и их использование</a></li>
		<li><a href="#%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE">Машинное слово</a></li>
		<li><a href="#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4">Метод</a></li>
		<li><a href="#%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8">Модель памяти</a></li>
		<li><a href="#%D0%BD%D0%BE%D0%BB%D1%8C">Ноль</a></li>
		<li><a href="#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-scope">Область видимости (scope)</a></li>
		<li><a href="#%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Обобщенное программирование</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Обработка входных данных</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B">Обработка ошибок (методы)</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">Объект</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Объявление</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80">Оператор</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Оператор присваивания</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B---%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D1%8B">Операторы - приоритеты</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5">Операторы арифметические</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B1%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5">Операторы битовые</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0">Операторы вывода и ввода</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Операторы доступа</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5">Операторы логические</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F">Операторы сравнения</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%83%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B5---%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%B0%D1%8F-%D0%B8-%D0%BF%D0%BE%D1%81%D1%82%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%B0%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D1%8B">Операторы унарные - префиксная и постфиксная формы</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0">Операторы, перегрузка</a></li>
		<li><a href="#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Определение</a></li>
		<li><a href="#%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D1%87%D0%B8%D0%BA">Отладчик</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Память динамическая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Память статическая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%81%D1%82%D0%B5%D0%BA%D0%BE%D0%B2%D0%B0%D1%8F">Память стековая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B2-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5">Память, работа в стандартной библиотеке</a></li>
		<li><a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F">Переменная</a></li>
		<li><a href="#%D0%BF%D0%BE%D0%BB%D0%B5">Поле</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2">Порядок байтов</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5">Потоки стандартные</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5">Потоки строковые</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5">Потоки файловые</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D1%83">Программирование по контракту</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D1%8F%D1%89%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Производящая функция</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD-namespace">Пространства имен (namespace)</a></li>
		<li><a href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC-%D1%82%D0%B8%D0%BF%D0%B0">Псевдоним типа</a></li>
		<li><a href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D1%8B%D0%B5-%D1%87%D0%B8%D1%81%D0%BB%D0%B0">Псевдослучайные числа</a></li>
		<li><a href="#%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F">Раздельная компиляция</a></li>
		<li><a href="#%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F">Рекурсия</a></li>
		<li><a href="#%D1%81%2B%2B-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-%D1%81">С++ (общие сведения, отношение с с)</a></li>
		<li><a href="#%D1%81%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Связывание</a></li>
		<li><a href="#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Специализация</a></li>
		<li><a href="#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0">Ссылка</a></li>
		<li><a href="#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F">Статическая переменная</a></li>
		<li><a href="#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D1%87%D0%BB%D0%B5%D0%BD-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">Статический член (класса)</a></li>
		<li><a href="#%D1%81%D1%82%D0%B5%D0%BA-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2">Стек вызовов</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%B0%D0%B6%D0%B8-%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Стражи включения</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D1%81-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D0%B8-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Строки (с-строки) и литералы, обработка</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-std%3A%3Astring-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Строки std::string, обработка</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0">Структура</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Структура данных</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B3%D1%80%D0%B0%D1%84">Структура данных «граф»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">Структура данных «дерево»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6">Структура данных «кортеж»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">Структура данных «массив»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B4%D0%B2%D1%83%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9">Структура данных «список двусвязный»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BE%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9">Структура данных «список односвязный»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">Структура данных «хеш-таблица»</a></li>
		<li><a href="#%D1%82%D0%B5%D0%BA%D1%81%D1%82-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8">Текст программы, комментарии</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-pod">Тип pod</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-void">Тип void</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9">Тип вещественный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9">Тип встроенный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Тип данных</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85---%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%B0">Тип данных - принципы выбора</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9">Тип копируемый</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9">Тип логический</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Тип перечисление</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9">Тип символьный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8">Тип стандартной библиотеки</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%86%D0%B5%D0%BB%D1%8B%D0%B9">Тип целый</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D1%8B%D0%B5">Типов преобразования неявные</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%8F%D0%B2%D0%BD%D1%8B%D0%B5">Типов преобразования явные</a></li>
		<li><a href="#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C">Указатель</a></li>
		<li><a href="#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C-%D0%BD%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E">Указатель на функцию</a></li>
		<li><a href="#%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BE%D0%BC">Управление доступом</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%82%D0%BE%D1%80-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">Функтор (функциональный объект)</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Функция</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F---%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0">Функция - перегрузка</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F---%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Функция - передача параметров, возврат значения</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-main">Функция main</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD---%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B">Шаблон - параметры</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Шаблонная функция</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF">Шаблонный тип</a></li>
		<li><a href="#abi">ABI</a></li>
		<li><a href="#pimpl">PIMPL</a></li>
		<li><a href="#raii">RAII</a></li>
		<li><a href="#ref-qualifiers-for-%2Athis">Ref-qualifiers for *this</a></li>
		<li><a href="#singleton">Singleton</a></li>
		<li><a href="#std%3A%3Abitset">std::bitset</a></li>
		<li><a href="#std%3A%3Aforward">std::forward</a></li>
		<li><a href="#std%3A%3Amove">std::move</a></li>
		<li><a href="#std%3A%3Ashared_ptr">std::shared_ptr</a></li>
		<li><a href="#std%3A%3Aunique_ptr">std::unique_ptr</a></li>
		<li><a href="#std%3A%3Aweak_ptr">std::weak_ptr</a></li>
		<li><a href="#%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BB%D0%B0%D1%81%D1%81">Абстрактный класс</a></li>
		<li><a href="#%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">Виртуальный вызов, виртуальные функции</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC">Динамический полиморфизм</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80%D1%8B">Зависимости, пакетные менеджеры</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BC%D0%B5%D1%80%D1%8B-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8">Замеры времени</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-final">Ключевое слово final</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-mutable">Ключевое слово mutable</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B9">Конструктор перемещающий</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-generic">Лямбды, generic</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82">Лямбды, захват</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Лямбды, использование</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Лямбды, общие сведения</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">Лямбды, хранение</a></li>
		<li><a href="#%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Множественное наследование</a></li>
		<li><a href="#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5">Наследование (в языке)</a></li>
		<li><a href="#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Наследование (ограничение доступа)</a></li>
		<li><a href="#%D0%BE%D0%BE%D0%BF-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B">Ооп, базовые принципы</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%87%D0%BB%D0%B5%D0%BD%D1%83-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%22">Оператор "доступ к члену через указатель"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%B0%D1%8F%22">Оператор "запятая"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-%D1%82%D0%B8%D0%BF%D1%83%22">Оператор "приведение к типу"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%22%D1%80%D0%B0%D0%B7%D1%8B%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%22">Оператор "разыменование"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B9">Оператор присваивания перемещающий</a></li>
		<li><a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5">Перемещение</a></li>
		<li><a href="#%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9-%D0%BA%D1%80%D0%B8%D1%82%D0%B5%D1%80%D0%B8%D0%B9">Подстановочный критерий</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Выравнивание</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Предупреждения</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B0%D1%8E%D1%89%D0%B5%D0%B5">Преобразование повышающее</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%B6%D0%B0%D1%8E%D1%89%D0%B5%D0%B5">Преобразование понижающее</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-bit_cast">Приведение типа bit_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-const_cast">Приведение типа const_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-dynamic_cast">Приведение типа dynamic_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-reinterpret_cast">Приведение типа reinterpret_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-static_cast">Приведение типа static_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Производные объекты, конструирование и уничтожение</a></li>
		<li><a href="#%D0%BF%D1%80%D1%8F%D0%BC%D0%B0%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0">Прямая передача</a></li>
		<li><a href="#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0%D1%8F">Ссылка (правая)</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Шаблон, специализация</a></li>
	</ol>
</details>

<hr style="width:25%;text-align:left;margin-left:0">

## l-value и r-value

`l-value` - это выражение, которое имеет идентификатор и адрес в памяти, куда можно присвоить значение.

`r-value` - это выражение, которое не имеет адреса в памяти и часто используется как значение.

### Примеры
```C++
int x = 5; // x - l-value, 5 - r-value
```

<hr style="width:25%;text-align:left;margin-left:0">

## nullptr, NULL, 0

`nullptr` - введен в стандарте C++11 и представляет собой безопасную замену для `NULL` и `0` в указателях. `nullptr` имеет тип `std::nullptr_t` и может быть присвоен любому указателю.

`0` - также используется для представления нулевого указателя.

`NULL` - это макрос, обычно определенный как `#define NULL 0`, который используется для представления нулевого указателя (наследство из C -> не используем).

В C++11 и более поздних стандартах рекомендуется использовать `nullptr` вместо `NULL` и `0`, так как `nullptr` имеет явный тип и предотвращает некоторые ошибки, связанные с неправильным использованием нулевых указателей.

### Примеры
```C++
int* ptr1 = nullptr;
int* ptr2 = NULL;
int* ptr3 = 0;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм бинарного поиска

Бинарный поиск — это эффективный алгоритм поиска, который используется для нахождения позиции заданного элемента в отсортированном массиве. Принцип работы бинарного поиска заключается в последовательном делении массива на две части и сравнении искомого значения со значением элемента в середине массива.

Преимущества бинарного поиска:
* Высокая эффективность: Время выполнения бинарного поиска — `O(log n)`, где `n` — количество элементов в массиве.
* Простота реализации: Легко реализовать и отладить.

Ограничения:
* Требует отсортированного массива.
* Подходит только для последовательного доступа: Не подходит для структур данных с произвольным доступом, таких как связные списки.

Сложность по времени: `O(log n)`

Сложность по памяти: `O(1)`

### Примеры
```C++
std::vector<int> vec = { 1, 3, 5, 7, 9, 11, 13 }; // Вектор уже отсортирован
int target = 7; // искомое значение
std::binary_search(vec.begin(), vec.end(), target) // true - найден, false - нет
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм сортировки, основные характеристики

Алгоритмы сортировки позволяют упорядочить данные для эффективного доступа и обработки. Основные характеристики алгоритмов сортировки включают сложность по времени и памяти, стабильность и адаптивность.

### Примеры
Пузырьковая сортировка (Bubble Sort)
* Сложность по времени: `O(n^2)` в худшем и среднем случае, `O(n)` в лучшем случае (если массив уже отсортирован).
* Сложность по памяти: `O(1)`, так как не требует дополнительной памяти.
* Стабильность: Стабильный (не меняет порядок равных элементов).
* Адаптивность: Адаптивен (способность алгоритма работать быстрее на частично отсортированных данных).

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритм хеширования

Это функция, преобразующая входные данные произвольной длины в строку фиксированной длины, часто называемую хеш-кодом. Полученный хеш обычно имеет меньший размер, чем исходные данные.

Хеширование используется во многих областях информационной безопасности, включая проверку целостности данных и аутентификацию. Алгоритмы хеширования позволяют распознавать изменённые данные, они применяются в базах данных для более эффективного доступа к данным, в цифровых подписях, блокчейнах и хранении паролей.

Свойства:
* Детерминированность: одни и те же входные данные всегда приводят к тому же хеш-коду.
* Быстрое вычисление: хеш можно вычислить относительно быстро для любого объема входных данных.
* Эффект лавины: небольшое изменение входных данных вызывает существенное изменение результата хеширования.
* Необратимость: невозможно восстановить исходные данные по их хеш-коду.
* Стойкость к коллизиям: сложность нахождения второго входного значения, которое имеет такой же хэш, как и данное входное значение (слабая/сильная).

### Примеры
```C++
std::unordered_map<std::string, int> umap;

// Вставка элементов в unordered_map
umap["apple"] = 2;
umap["banana"] = 4;
umap["orange"] = 3;

// Альтернативный способ вставки с использованием метода insert
umap.insert({ "pear", 5 });
```

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритмы стандартной библиотеки

Стандартная библиотека - коллекция классов, функций, макросов и констант.

Находятся в `<algorithm>`.

Основные категории алгоритмов:
* Алгоритмы поиска и проверки.
* Алгоритмы сортировки и упорядочивания.
* Алгоритмы модификации.
* Алгоритмы копирования и перемещения.
* Алгоритмы генерации и удаления.
* Алгоритмы численных операций.

### Примеры
```C++
int x = 1;
int y = 2;
std::min(x, y); // 1
std::max(x, y); // 2

std::vector<int> vec = { 1, 2, 3, 4, 5 };
std::find(vec.begin(), vec.end(), 3); // поиск индекса эллемента '3'

std::binary_search(vec.begin(), vec.end(), 3); // true - '3' найдено, false - '3' не найдено

std::vector<int> vec = {5, 3, 1, 4, 2};
std::sort(vec.begin(), vec.end()); // vec = { 1, 2, 3, 4, 5 }

std::reverse(vec.begin(), vec.end()); // vec = { 5, 4, 3, 2, 1 }

std::replace(vec.begin(), vec.end(), 1, 9); // vec = { 5, 4, 3, 2, 9 }

std::vector<int> vec_copy(5);
std::copy(vec.begin(), vec.end(), vec_copy.begin()); // vec_copy = { 5, 4, 3, 2, 9 }

std::vector<int> vec_move(5);
std::move(vec_copy.begin(), vec_copy.end(), vec_move.begin()); // vec_move = { 5, 4, 3, 2, 9 } vec_copy = { }
```

<hr style="width:25%;text-align:left;margin-left:0">

##  Алфавит и идентификатор

Алфавит C++ состоит из следующих символов:

1. Буквы:
* Заглавные латинские буквы: `A-Z`.
* Строчные латинские буквы: `a-z`.
* Цифры: `0-9`.

2. Специальные символы:
* Символы пунктуации: `+`, `-`, `*`, `/`, `%`, `=`, `&`, `|`, `!`, `^`, `~`, `<`, `>`, `?`, `:`, `;`, `,`, `.`, `@`, `#`, `$`, `_`
* Скобки и операторы: `()`, `{}`, `[]`, `::`, `->`, `.`

3. Пробелы и управляющие символы:
* Пробел, табуляция и другие символы управления, такие как `\n` (новая строка), `\t` (табуляция) и т.д.
* Идентификаторы — это имена, которые программист присваивает переменным, функциям, классам, объектам и другим элементам программы. Правила именования идентификаторов в C++:

Начало идентификатора:
* Должен начинаться с буквы (заглавной или строчной) или символа подчеркивания `_`
* Не может начинаться с цифры.

Содержимое идентификатора:
* Может содержать буквы, цифры и символы подчеркивания.
* Пробелы и специальные символы (кроме `_`) не допускаются.

Регистр имеет значение:
* C++ различает идентификаторы, записанные в разном регистре. Например, `Variable` и `variable` считаются разными идентификаторами.

Ключевые слова:
* Идентификаторы не могут совпадать с ключевыми словами языка C++ (например, `int`, `class`, `return` и т.д.).

Стиль именования:
* Стиль именования может следовать соглашениям, принятым в проекте или команде. Например, CamelCase, snake_case и т.д.

### Примеры
```C++
int myVariable;       // допустимый идентификатор
int _my_variable;     // допустимый идентификатор
int variable2;        // допустимый идентификатор
int Variable;         // допустимый идентификатор, отличается от "variable"
int 2variable;        // недопустимый идентификатор, начинается с цифры
int my-variable;      // недопустимый идентификатор, содержит дефис
int int;              // недопустимый идентификатор, совпадает с ключевым словом
```

<hr style="width:25%;text-align:left;margin-left:0">

## Арифметика указателей

К указателю можно прибавлять число, тогда он станет указывать на следующий элемент(если он указывал на элемент массива). Если указатель вышел за пределы массива, то результат разыменования не определён. Можно вычитать указатель из указателя в пределах одного массива, результатом будет количество элементов между ними.

### Примеры
```C++
int arr[] = { 1, 2, 3, 4, 5 };
int *ptr = arr; // Указатель на начало массива arr

std::cout << "Element 1: " << *ptr << std::endl; // Вывод первого элемента

++ptr; // Перемещение указателя на следующий элемент
std::cout << "Element 2: " << *ptr << std::endl; // Вывод второго элемента

ptr += 2; // Перемещение указателя на два элемента вперед
std::cout << "Element 4: " << *ptr << std::endl; // Вывод четвертого элемента

--ptr; // Перемещение указателя на 1 элемент назад
std::cout << "Element 3: " << *ptr << std::endl; // Вывод третьего элемента
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД

Абстрактный Тип Данных - интерфейс, описывающий набор операций над типом данных, но не то как они реализованы(логику использования). Операции, описанные в любом АТД - создание, уничтожение, копирование. АТД скрывает детали реализации, лишь предоставляя интерфейс.

### Примеры
* Стек
* Очередь
* Двусвязный список

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «cтек» и варианты реализации

Абстрактный тип данных "стек" реализует структуру данных с наиболее последним приходом, первым на выход (LIFO - Last-In, First-Out). Элементы добавляются на вершину стека и удаляются с вершины.

Основные операции, которые определяют интерфейс стека, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `push` - добавление элемента в конец стека.
* `pop` - удаление и возвращение элемента с конца стека.
* `top` или `peek` - возвращение элемента с конца стека без удаления.
* `isEmpty` - проверка, пуст ли стек.
* `size` - получение числа элементов в стеке.

Реализация на основе массива и связанного списка.
В стандартной библиотеке реализован на deque(дэк) и представлен в виде `std::stack<T>`.

<hr style="width:25%;text-align:left;margin-left:0">АТД «дэк» и варианты реализации

## АТД «дэк» и варианты реализации

Двусвязная очередь - это абстрактный тип данных, представляет собой структуру данных, которая поддерживает добавление и удаление элементов с обоих концов.

Реализация на основе массива и двусвязанного списка.

Основные операции, которые определяют интерфейс дэка, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `push_back` - добавление элемента в конец дэка.
* `push_front` - добавление элемента в начало дэка.
* `pop_back` - удаление и возвращение элемента с конца дэка.
* `pop_front` - удаление и возвращение элемента с начала дэка.
* `top` или `peek` - возвращение элемента с конца дэка без удаления.
* `isEmpty` - проверка, пуст ли дэк.
* `size` - получение числа элементов в дэке.

В стандартной библиотеке - `std::deque<T>`.

### Примеры
```C++
std::deque<int> myDeque;

myDeque.push_back(10); // Добавление в конец
myDeque.push_front(5); // Добавление в начало

// Доступ к элементам "дэка"
std::cout << "Front element: " << myDeque.front() << std::endl; // '5'
std::cout << "Back element: " << myDeque.back() << std::endl; // '10'

myDeque.pop_front(); // Удаление из начала
myDeque.pop_back(); // Удаление из конца
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «массив» и варианты реализации

Типы:
* Статический массив: Фиксированный размер, быстрый доступ к элементам и вставка.
* Динамический массив: Размер меняется во время выполнения программы, быстрый доступ к элементам, но вставка при расширении занимает дольше времени.

Основные операции, которые определяют интерфейс массива, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `empty` - проверка, пуст ли массив.
* `size` - получение числа элементов в массивe.

В стандартной библиотеке представлены в виде `std::array<T>` и `std::vector<T>`.

### Примеры
```C++
std::vector<int> vec;

// Добавляем элементы в конец вектора
vec.push_back(1);
vec.push_back(2);

// Выводим элементы вектора
for (int i = 0; i < vec.size(); ++i) {
    std::cout << "Element " << i << ": " << vec[i] << std::endl;
}

vec[1] = 5; // Изменяем значение элемента по индексу 1 на '5'

// --------------------------------------------------------------

std::array<int, 5> arr = { 1, 2, 3, 4, 5 };

// Выводим элементы массива
std::cout << "Array elements:" << std::endl;
for (int i = 0; i < arr.size(); ++i) {
    std::cout << "Element " << i << ": " << arr[i] << std::endl;
}

arr[1] = 6; // Изменяем значение элемента по индексу 1 на '6'
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «матрица» и варианты реализации

Это абстрактный тип данных, описывающий набор операций над элементами, расположенными в виде таблицы: создание, уничтожение, копирование, доступ к элементу по индексу, получение количества столбцов, получение количества строк.

Можно реализовать через массив с приведенным индексом, или массивы одинаковой длины в другом массиве.

### Примеры
```C++
std::vector<std::vector<int>> mat = {
    { 5, 8, 2 },
    { 8, 3, 1 },
    { 5, 3, 9 }
};

std::array<std::array<int, 3>, 3> matrix = {
    { 5, 8, 2 },
    { 8, 3, 1 },
    { 5, 3, 9 }
};
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «множество» и варианты реализации

Это структура данных, которая содержит уникальные элементы без какого-либо порядка.

Можно реализовать через массив с проверкой на дубликаты или хэш-функцию.

Основные операции, которые определяют интерфейс множества, включают:
* `insert` - вставка эллемента во множество.

В стандартной библиотеке представлена в виде `std::set<T>`.

### Примеры
```C++
std::set<int> mySet;

// Вставляем элементы в множество
mySet.insert(3);
mySet.insert(1);
mySet.insert(5);
mySet.insert(2);
mySet.insert(1); // Этот элемент не будет добавлен, так как '1' уже есть во множестве
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «очередь с приоритетом» и варианты реализации

Это структура данных, которая хранит элементы с определенным приоритетом. Элемент с более высоким приоритетом извлекается раньше, чем элементы с более низким приоритетом.

Можно реализовать через массив, вставляя эллемент в определенное место.

В стандартной библиотеке представлена в виде `std::priority_queue<T>`.

### Примеры
```C++
std::priority_queue<int> pq;

pq.push(30); // низкий приоритет
pq.push(100); // высокий приоритет
pq.push(50); // средний приоритет

while (!pq.empty()) {
    std::cout << pq.top() << " ";
    pq.pop();
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «очередь» и варианты реализации

Представляет собой структуру данных, работающую по принципу FIFO (First In, First Out), что означает, что первый элемент, добавленный в очередь, будет первым извлечен из неё.

Может быть реализована несколькими способами: с использованием массивов, связных списков.

Основные операции, которые определяют интерфейс очереди, включают:
* `push` - добавление элемента в конец очереди.
* `pop` - удаление и возвращение элемента с конца очереди.
* `empty` - проверка, пуста ли очередь.
* `size` - получение числа элементов в очереди.

В стандартной библиотеке представлена в виде `std::queue<T>`.

### Примеры
```C++
std::queue<int> q;
 
q.push(0); // q = 0
q.push(1); // q = 0 1
q.push(2); // q = 0 1 2
q.push(3); // q = 0 1 2 3

q.size() // 4

q.pop(); // удаляет первый эллемент 0

q.size() // 3
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «полином» и варианты реализации

Это абстрактный тип данных, описывающий операции над многочленом.

Можно реализовать через массив, хранящий коэффициенты.

Основные операции, которые определяют интерфейс полинома, включают:
* Сложение полиномов.
* Доступ к коэффициенту по индексу.
* Умножение на число.

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «словарь» и варианты реализации

Представляет собой структуру данных, описывающую операции над набором пар типов, где один из типов является ключём, а другой - значением.

Может быть реализован несколькими способами: с использованием хэш-функции и деревом.

Основные операции, которые определяют словарь очереди, включают:
* `operator[]` - получение/запись эллемента по ключу.
* `insert` - добавление элемента в словарь.
* `erase` - удаление и элемента по ключу.
* `empty` - проверка, пустой ли словарь.
* `size` - получение числа элементов в словаре.

В стандартной библиотеке представлены в виде `std::map<T>`(сбалансированное красно-черное дерево) и `std::unordered_map<T>`(хэш-функция).

### Примеры
```C++
std::map<std::string, int> myMap;

// Добавляем элементы в map
myMap["apple"] = 5;
myMap["banana"] = 3;
myMap["orange"] = 7;

myMap.erase("apple"); // Удаляем элемент из map

// ------------------------------------------------

std::unordered_map<std::string, int> myUnorderedMap;

// Добавляем элементы в unordered_map
myUnorderedMap["apple"] = 5;
myUnorderedMap["banana"] = 3;
myUnorderedMap["orange"] = 7;

myUnorderedMap.erase("apple"); // Удаляем элемент из unordered_map
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «строка» и варианты реализации

Представляет собой структуру данных, описывающую операции над последовательностью символом.

Может быть реализована несколькими способами: массивом из символов(char'ов).

Основные операции, которые определяют строку очереди, включают:
* `operator[]` - получение/запись символа по индексу.
* `erase` - удаление и символа по индексу.
* `empty` - проверка, пустая ли строка.
* `length` - получение числа символов в строке.

В стандартной библиотеке представлена в виде `std::string`.

### Примеры
```C++
std::string str = "Hello";

str.length() // 5

str[0]; // 'H'

str.erase(0) // str = "ello"

str.empty() // false
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «число» и варианты реализации

Представляет собой математическую абстракцию чисел и операции над ними.

В рамках программирования АТД «число» может быть представлен различными способами в зависимости от требований к точности и диапазону значений. 

Основные операции, которые определяют число очереди, включают:
* Операторы арифметических операций.
* Операторы сравнения.

В C++ представлены в виде `int`, `float`, `double` и т.д.

### Примеры
```C++
int a = 10;
float b = 3.14;
double c = 354654.34686796345;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Инстанциирование

Генерация объявления функции или типа по шаблону и его аргументам. Осуществляется во время компиляции.

### Примеры
```C++
// Объявление шаблона функции
template <typename T>
T add(T a, T b)
{
    return a + b;
}

// Объявление шаблона класса
template <typename T>
class Box
{
public:
    Box(T v) : value(v) {}

private:
    T value;
};

int main()
{
    // Инстанциирование шаблонной функции с типом int
    int intResult = add<int>(3, 4);
    
    // Инстанциирование шаблонного класса с типом int
    Box<int> intBox(123);

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Оператор "приведение к типу"

Оператор приведения к типу `()` позволяет выполнить явное преобразование к другому типу. Можно определять для пользовательских типов: `operator typename ()`.

### Примеры
```C++

class Example
{
public:
	Example(std::string name)
	 : name_(name) {
	}

	operator const char* () // Оператор приведения класса Example к типу const char*
	{
		return name_.c_str();
	}
private:
	std::string name_;
};

int main()
{
	double a 5.3;
	int b = (int)(a); // Приведение встроенных типов
	
	Example c("example");
	std::cout << (const char*)(c) << '\n'; // Приведение пользовательского типа
	return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Оператор "разыменование"

Оператор разыменование позволяет получить доступ к объекту, на который указывает указатель для чтения или изменения значения;

### Примеры
```C++
int main()
{
	int a = 10;
	int* ptr = &a;
	std::cout << *ptr << '\n';
	*ptr = 4;
	std::cout << *ptr << '\n';
}
//Вывод:
//10
//4
```

<hr style="width:25%;text-align:left;margin-left:0">

## Оператор присваивания перемещающий

Оператор присваивания пермещающий - перегрузка оператора присваивания, который в качестве аргумента принимает rvalue ссылку на тип. Использует семантику перемещения для присваивания значения.

### Примеры
```C++
class Example
{
public:
	Example& operator=(const Example& value)
	{
		if ( *this == value ) return *this;
		data_ = value.data_;
		return *this;
	}

	Example& operator=(Example&& value)
	{
		if ( *this == value ) return *this;
		std::swap(copy.data_, data_);
		copy.data_.Clear(); 
		return *this;
	}
	
private:
	std::vector data_;
};

int main()
{
	Example arr1;
	//....
	Example arr2;
	arr2 = arr1; // Вызывается обычный оператор присваивания
	Example arr3;
	arr3 = std::move(arr1); // Вызывается перемещающий оператор присваивания
	return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Перемещение

Перемещение - передача ресурсов от одного объекта путем передачи управления над этими ресурсами. Используется в тех случаях, когда не требуется сохранять состояния объекта, из которого берем значение, чтобы избежать копирования. Для перемещения типу необходимо иметь перемещающий конструктор и перемещающий оператор присваивания. Чтобы вызвать перемещающий вариант конструктора/оператора присваивания используется функция std::move(), которая возвращает rvalue ссылку(правую ссылку) на объект.

### Примеры
```C++
class Example
{
public:
	//....
	Example(Example&& copy)
	{
		std::swap(copy.data_, data_); 
	}
	
	Example& operator=(Example&& value)
	{
		if ( *this == value ) return *this;
		std::swap(copy.data_, data_);
		copy.data_.Clear(); 
	}
	
private:
	std::vector data_;
};

int main()
{
	Example arr1;
	//....
	Example arr2(std::move(arr1)); // После этой операции arr1 будет пустым,а arr2 будет содержать значения arr1 до операции
	Example arr3;
	arr3 = std::move(arr2); // Аналогично операции выше
	return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Подстановочный критерий

Подстановочный критерий - производный класс должен обеспечивать интерфейс и контракт родительского класса, т.е. функция, которая работает с базовым классом, должна иметь возможность работать с производным классом, не зная об этом.

### Примеры
```C++
class Base
{
public:
	int Add(double item)
	{
		//... добавление элемента
		if(fail){
			return -1;
		}
		return index;
	}
	// Функция должна возвращать индекс только что добавленного элемента или -1 при ошибке при добавлении
};

class Derived : public Base
{
public:
	int Add(double item) override 
	{
		//... добавление элемента
		return -1;
	}
	// Критерий подстановки не выполняется, так как функция возвращает -1 даже при успешной вставке элемента, хотя должна возвращать индекс элемента
};
```

<hr style="width:25%;text-align:left;margin-left:0">

## Выравнивание

Выравнивание - добавление компилятором незначащий байтов для выравнивания размера типа(структуры) до числа, кратного заданному. Обычно кратно 4, так как чаще всего машинное слово имеет размер 4 байта.

### Примеры
```C++
struct A{
	char a; // 1 байт
	// 3 незначащих байта
	int b; // 4
	char c; // 1
	// 3 незначащих байта
};
// размер 12 байтов

struct B{
	int a; // 1 
	char b; // 1
	// 2 незначащих байта
	int c; // 4
};
// размер 8 байтов
```

### Alignas и alignof

Спецификатор `alignas` позволяет вручную задать размер выравнивания для типа. Если размер выравнивания меньше, чем необходимо для хранения типа, то поведение неопределено.

Оператор `alignof` возвращает выравнивание типа в байтах.

### Примеры
```C++
struct A{
	int a; // 4 байта
	int b; // 4 байта
	int c; // 4 байта
}
// размер 12 байтов

struct alignas(16) B{
	int a; // 4 байта
	int b; // 4 байта
	int c; // 4 байта
	// 4 байта для выравнивания
}
// размер 16 байтов

int main()
{
	std::cout << alignof(A) << ' ' << alignof(B) << '\n';
	return 0;
};
// Вывод:
// 12 16
```

<hr style="width:25%;text-align:left;margin-left:0">

## Предупреждения

Предупреждения (warnings) компилятора помогают выявлять потенциальные проблемы в коде, такие как ошибки времени выполнения, неиспользуемые переменные, возможные утечки памяти и другие ситуации, которые могут привести к нежелательному поведению программы. Предупреждения позволяют программисту заранее исправить эти проблемы. 

### Примеры
* Неиспользуемая переменная:
```C++
int main()
{
    int x = 10; // Предупреждение: переменная x не используется
    return 0;
}
```

* Несовпадение типов:
```C++
int main()
{
    int x = 10;
    double y = x; // Предупреждение: неявное преобразование int в double
    return 0;
}
``` 

* Неразрешенные возвращаемые значения функций:
```C++
int foo()
{
    return 42;
}

int main()
{
    foo(); // Предупреждение: возвращаемое значение функции foo() не используется
    return 0;
}
```

*Потенциально некорректное использование указателей:
```C++
int main()
{
    int* p = nullptr;
    *p = 42; // Предупреждение: разыменование нулевого указателя
    return 0;
}
```

* Использование устаревших функций:
```C++
#include <stdio.h>

int main()
{
    gets(nullptr); // Предупреждение: функция gets() устарела и небезопасна
    return 0;
}
```

### Управление предупреждениями

Управление предупреждениями:

* В некоторых компиляторах можно настроить уровень предупреждений.

* Можно подавлять отдельные предупреждения.

* Использование атрибутов в C++.

### Примеры
```C++
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4996) // Подавление предупреждения для устаревшей функции
#endif

#include <stdio.h>

int main()
{
    gets(nullptr); // Предупреждение подавлено
    return 0;
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif

// --------------------------------------------------------------------

[[maybe_unused]] int unusedVariable = 10; // Подавление предупреждения о неиспользуемой переменной
```

<hr style="width:25%;text-align:left;margin-left:0">

## Преобразование повышающее

Повышающее преобразование (upcasting) — это процесс приведения указателя или ссылки на объект производного класса к указателю или ссылке на базовый класс. Повышающее преобразование всегда безопасно и выполняется неявно, поскольку объект производного класса всегда является объектом базового класса.

### Примеры
```C++
class Base
{
public:
    virtual void show() const
    {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base
{
public:
    void show() const override
    {
        std::cout << "Derived class" << std::endl;
    }
};

void print(const Base& base)
{
    base.show();
}

Derived derivedObj;
Base* basePtr = &derivedObj; // Повышающее преобразование
Base& baseRef = derivedObj;  // Повышающее преобразование

basePtr->show(); // Вызов виртуальной функции через указатель на базовый класс
baseRef.show();  // Вызов виртуальной функции через ссылку на базовый класс

print(derivedObj); // Передача объекта производного класса в функцию, принимающую ссылку на базовый класс
```

<hr style="width:25%;text-align:left;margin-left:0">

## Преобразование понижающее

Понижающее преобразование (downcasting) в — это приведение указателя или ссылки на базовый класс к указателю или ссылке на производный класс. В отличие от повышающего преобразования (upcasting), которое всегда безопасно и автоматически, понижающее преобразование может быть небезопасным, так как компилятор не может гарантировать, что указатель или ссылка на базовый класс действительно указывают на объект производного класса.

Для выполнения понижающего преобразования можно использовать `dynamic_cast<>`, который выполняет проверку типа во время выполнения (runtime check). 

### Примеры
```C++
class Base
{
public:
    virtual ~Base() = default;
    virtual void show() const
    {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base
{
public:
    void show() const override
    {
        std::cout << "Derived class" << std::endl;
    }
    void specificMethod() const
    {
        std::cout << "Specific method of Derived class" << std::endl;
    }
};

void process(Base* basePtr)
{
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr) {
        derivedPtr->specificMethod();
    } else {
        std::cout << "BasePtr is not pointing to a Derived object." << std::endl;
    }
}

std::unique_ptr<Base> basePtr1 = std::make_unique<Derived>();  // Указатель на производный объект
std::unique_ptr<Base> basePtr2 = std::make_unique<Base>();     // Указатель на базовый объект

process(basePtr1.get());  // Ожидаем успешное преобразование
process(basePtr2.get());  // Ожидаем неудачное преобразование
```

<hr style="width:25%;text-align:left;margin-left:0">


## Приведение типа bit_cast<>

`bit_cast<>` - это функция, представленная в стандарте C++20, которая позволяет безопасно преобразовывать одни биты данных в другие без изменения их значения или представления. Она полезна для операций с бинарными данными, такими как преобразование между числовыми типами и структурами, когда требуется строгое копирование битов. 

### Примеры
```C++
//Преобразование между числовыми типами:
float f = 3.14;
int i = std::bit_cast<int>(f); 

// --------------------------------------

//Преобразование между структурами:
struct Point
{
    float x;
    float y;
};

struct PackedPoint
{
    long long packedData;
};

Point pt = { 1.5f, 2.5f };
PackedPoint packedPt = std::bit_cast<PackedPoint>(pt);
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа const_cast<>

Позволяет убрать/добавить модификатор const с типа(преобразовывать `const` тип в обычный тип и обратно). 

### Примеры
```C++
const int num = 10;
int& numRef = const_cast<int&>(num);
numRef = 20; // Разрешено, но не рекомендуется

// -----------------------------------------

int value = 100;
const int* ptr = &value;
int* ptrMutable = const_cast<int*>(ptr);
*ptrMutable = 200; // Разрешено

// -----------------------------------------

class MyClass
{
public:
    void func() { std::cout << "Non-const func" << std::endl; }
    void func() const { std::cout << "Const func" << std::endl; }
};

const MyClass obj;
const_cast<MyClass&>(obj).func(); // Вызывает неконстантную версию func() 
const_cast<const MyClass&>(obj).func(); // Вызывает константную версию func() 
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа dynamic_cast<>

Оператор `dynamic_cast<>` предназначен для выполнения безопасного приведения типов в иерархиях наследования с использованием полиморфизма. Он позволяет проверить тип объекта во время выполнения и выполнить приведение указателей или ссылок к типу, производному от базового класса. Важно отметить, что dynamic_cast<> работает только с классами, имеющими хотя бы один виртуальный метод.
Основные случаи использования `dynamic_cast<>`:
* Приведение указателей или ссылок на производные классы
* Приведение указателей с использованием полиморфных типов
* Приведение ссылок

### Примеры
```C++
class Base
{
public:
    virtual ~Base() = default;
};

class Derived : public Base
{
public:
    void specificMethod() {}
};

void process(Base* basePtr)
{
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr) {
        derivedPtr->specificMethod();
    } else {
        std::cout << "Не удалось привести тип к Derived" << std::endl;
    }
}

void someFunction(Base& baseRef)
{
    try {
        Derived& derivedRef = dynamic_cast<Derived&>(baseRef);
        // Успешное приведение типа
        derivedRef.specificMethod();
    } catch (std::bad_cast& e) {
        // Не удалось привести тип
        std::cout << "Не удалось привести тип к Derived: " << e.what() << std::endl;
    }
}

int main()
{
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); //Приведение указателя на родительский класс к указателю на класс наследник

    if (derivedPtr) {
        // Успешное приведение типа
        derivedPtr->specificMethod();
    } else {
        // Не удалось привести тип
        std::cout << "Не удалось привести тип к Derived" << std::endl;
    }
	
// -------------------------------------------------
	
    Base basePtr = new Derived();
    process(basePtr); // Приведение указателя
	
    // -------------------------------------------------
	
    Base basePtr();
    someFunction(basePtr); //Приведение ссылок
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа reinterpret_cast<>

Оператор `reinterpret_cast<>` используется для выполнения принудительного преобразования одного типа указателя или ссылки в другой тип. Этот оператор позволяет интерпретировать битовую последовательность одного объекта как битовую последовательность другого объекта любого типа. Однако его использование требует особой осторожности, так как `reinterpret_cast<>` не выполняет проверок типов и может привести к непредсказуемому поведению программы, если преобразование неверно использовано.
Основные случаи использования `reinterpret_cast<>`:
* Преобразование указателей и ссылок
* Преобразование между указателями на классы
* Преобразование между указателями и целочисленными типами

### Примеры
```C++
int* intptr = new int(10);
double* doubleptr = reinterpret_cast<double>(intptr); // Преобразование указателя int в double*

// ---------------------------------

class Base
{
    // ...
};

class Derived : public Base
{
    // ...
};

Base* baseptr = new Base();
Derived* derivedptr = reinterpret_cast<Derived>(baseptr); // Преобразование указателя на базовый класс к указателю на производный класс

// ---------------------------------

void ptr = nullptr;
uintptr_t addr = reinterpret_cast<uintptr_t>(ptr); // Преобразование указателя в целочисленный тип
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа static_cast<>

Оператор `static_cast<>` используется для выполнения явного приведения типов во время компиляции. Он позволяет преобразовывать значения одного типа в другой, когда такое преобразование является безопасным и известным на этапе компиляции.
Вот основные случаи использования `static_cast<>`:
* Преобразование числовых типов
* Преобразование указателей
* Преобразование ссылок
* Преобразование между перечислимыми типами и их значениями

### Примеры
```C++
double a = 4.3;
int b = std::static_cast<int>(a);

// --------------------------------------------

Base* basePtr = new Derived();
Derived* derivedPtr = static_cast<Derived*>(basePtr); // Преобразование указателя на базовый класс к указателю на производный класс

// --------------------------------------------

int i = 10;
double& dRef = static_cast<double&>(i); // Преобразование ссылки int& к double&

// --------------------------------------------

enum class Color { Red, Green, Blue };
int colorValue = static_cast<int>(Color::Green); // Преобразование значения перечислимого типа в int
```

<hr style="width:25%;text-align:left;margin-left:0">

## Производные объекты, конструирование и уничтожение

В C++ производные объекты (derived objects) относятся к объектам, которые наследуют свойства и методы от базовых классов. Конструирование и уничтожение производных объектов являются важными аспектами, которые определяют, как происходит инициализация и освобождение ресурсов во время жизненного цикла объектов. Давайте рассмотрим эти аспекты более подробно.

Конструирование производных объектов
При конструировании производного объекта происходит следующее:

Конструктор базового класса: Сначала вызывается конструктор базового класса. Это происходит в порядке иерархии наследования от верхнего базового класса до непосредственного родителя производного класса.

Конструктор производного класса: После инициализации базового класса вызывается конструктор производного класса. В этом конструкторе происходит инициализация собственных полей производного класса.

Уничтожение производных объектов
При уничтожении производного объекта происходит следующее:

Деструктор производного класса: Сначала вызывается деструктор производного класса. В деструкторе производного класса освобождаются ресурсы, выделенные для его полей.

Деструктор базового класса: После выполнения деструктора производного класса вызывается деструктор базового класса. Это происходит в обратном порядке от производного класса к базовым классам.

В родительском классе деструктор должен быть виртуальный, чтобы при удалении родительского класса, полученного путем повышающего преобразования не происходила утечка памяти.

### Примеры
```C++
// Базовый класс
class Base
{
public:
    Base()
    {
        std::cout << "Конструктор Base" << std::endl;
    }
    virtual ~Base()
    {
        std::cout << "Деструктор Base" << std::endl;
    }
};

// Производный класс
class Derived : public Base
{
public:
    Derived()
    {
        std::cout << "Конструктор Derived" << std::endl;
    }
    ~Derived()
    {
        std::cout << "Деструктор Derived" << std::endl;
    }
};

int main()
{
    Derived d; // Создание производного объекта
    return 0;
}
//Вывод:
//Конструктор Base
//Конструктор Derived
//Деструктор Derived
//Деструктор Base
```

<hr style="width:25%;text-align:left;margin-left:0">

## Прямая передача

Прямая передача - передача аргументов без лишнего копирования/перемещения. Используется в обёрточных функциях для передачи аргументов. Реализуется при помощи функции `std::forward<T>`, которая передает значение сохраняя его тип(lvalue/rvalue). 

### Примеры
```C++
#include <utility> // Для std::forward

// Функция process для обработки строки rvalue
void process(std::string&& str)
{
    std::cout << "Обработка rvalue строки: " << str << std::endl;
}

// Функция process для обработки строки lvalue
void process(const std::string& str)
{
    std::cout << "Обработка lvalue строки: " << str << std::endl;
}

// Шаблонная функция wrapper с универсальной ссылкой
template <typename T>
void wrapper(T&& arg)
{
    // Передаем аргумент в функцию process с помощью std::forward,
    // чтобы сохранить его тип (lvalue или rvalue)
    process(std::forward<T>(arg));
}

int main()
{
    std::string s = "Hello";
    wrapper(s);            // Вызов с lvalue
    wrapper(std::move(s)); // Вызов с rvalue

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Ссылка (правая)

Правая ссылка(rvalue) - ссылка на временный объект. Используется для избежания ненужного копирования(семантика перемещения), так как позволяет перемещать ресурсы одного объекта в другой.

### Примеры
```C++
std::string str1 = "Hello, World!";
std::cout << "str1: " << str1 << std::endl;

// Перемещаем содержимое str1 в str2
std::string str2 = std::move(str1);
std::cout << "После перемещения:" << std::endl;
std::cout << "str1: " << str1 << std::endl;
std::cout << "str2: " << str2 << std::endl;

//Вывод:
//str1: Hello, World!
//После перемещения:
//str1: 
//str2: Hello, World!
```

<hr style="width:25%;text-align:left;margin-left:0">

## Шаблон, специализация

Шаблон - это конструкция, которая на этапе компиляции создает обычный тип или функцию на основе аргументов. Используется в качестве альтернативы многочисленным перегрузкам, когда поведение функции для многочисленного набора разных типов одинаково или похоже.

Специализация - определение функций или типов для специального набора аргументов.

### Примеры
```C++
// Объявление шаблона функции
template <typename T>
T add(T a, T b)
{
    return a + b;
}

//специализация шаблона функции
template <>
std::string add<std::string>(std::string a, std::string b)
{
    return a.append(b);
}

// Объявление шаблона класса
template <typename T>
class Box
{
public:
    Box(T v) : value(v) {}

private:
    T value;
};
```

<hr style="width:25%;text-align:left;margin-left:0">

<p align="right">(<a href="#readme-top">Вернуться в начало</a>)</p>
