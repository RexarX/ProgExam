<a name="readme-top"></a>

<details>
	<summary>Вопросы</summary>
	<ol>
		<li><a href="#l-value-%D0%B8-r-value">l-value и r-value</a></li>
		<li><a href="#nullptr-null-0">nullptr, null, 0</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">Алгоритм бинарного поиска</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D1%85%D0%B0%D1%80%D0%B0%D0%BA%D1%82%D0%B5%D1%80%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B8">Алгоритм сортировки, основные характеристики</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D1%85%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Алгоритм хеширования</a></li>
		<li><a href="#%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8">Алгоритмы стандартной библиотеки</a></li>
		<li><a href="#%D0%B0%D0%BB%D1%84%D0%B0%D0%B2%D0%B8%D1%82-%D0%B8-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80">Алфавит и идентификатор</a></li>
		<li><a href="#%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9">Арифметика указателей</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4">АТД</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-c%D1%82%D0%B5%D0%BA-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «cтек» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%B4%D1%8D%D0%BA-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «дэк» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «массив» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «матрица» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «множество» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-%D1%81-%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «очередь с приоритетом» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «очередь» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%BF%D0%BE%D0%BB%D0%B8%D0%BD%D0%BE%D0%BC-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «полином» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «словарь» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «строка» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-%D0%B8-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">АТД «число» и варианты реализации</a></li>
		<li><a href="#%D0%B0%D1%82%D0%B4-%D0%B8-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">АТД и структура данных</a></li>
		<li><a href="#%D0%B1%D0%B5%D1%81%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5-%D1%86%D0%B8%D0%BA%D0%BB%D1%8B">Бесконечные циклы</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-library-%D0%B8-%D0%BA%D0%B0%D1%80%D0%BA%D0%B0%D1%81-framework">Библиотека (library) и каркас (framework)</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Библиотека динамическая</a></li>
		<li><a href="#%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Библиотека статическая</a></li>
		<li><a href="#%D0%B1%D1%83%D1%84%D0%B5%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D1%80%D0%B8-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2">Буферизация при использовании потоков</a></li>
		<li><a href="#%D0%B2%D0%B0%D0%BB%D0%B8%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2">Валидность итераторов</a></li>
		<li><a href="#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA">Ввод и вывод, обработка ошибок</a></li>
		<li><a href="#%D0%B2%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0">Ввод и вывод, стандартная библиотека</a></li>
		<li><a href="#%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">Встроенный массив</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BD%D0%B5%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9">Вывод и ввод, неформатированный</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Вывод и ввод, позиционирование</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8">Вывод и ввод, потоки</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8">Вывод и ввод, файловые потоки</a></li>
		<li><a href="#%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4-%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9">Вывод и ввод, форматированный</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Выражение</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F---%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D1%8B-%D0%B8-%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Выражения - приоритеты и порядок вычисления</a></li>
		<li><a href="#%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0">Глобальные и локальные имена</a></li>
		<li><a href="#%D0%B4%D0%B5%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80">Деструктор</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B-%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">Диапазоны арифметических типов</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%B0%D0%BF%D0%B0%D0%B7%D0%BE%D0%BD%D1%8B-%D0%B8-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0%D0%B4-%D0%BD%D0%B8%D0%BC%D0%B8">Диапазоны и операции над ними</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E">Динамическое управление памятью</a></li>
		<li><a href="#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0%D0%BC-%D0%B2-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B5">Доступ к именам в пространстве</a></li>
		<li><a href="#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%87%D0%BB%D0%B5%D0%BD%D0%B0%D0%BC">Доступ к членам</a></li>
		<li><a href="#%D0%B4%D1%80%D1%83%D0%B7%D1%8C%D1%8F-friend">Друзья (friend)</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B---%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Заголовочные файлы - практика использования</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD-%D0%B4%D1%8B%D1%80%D1%8F%D0%B2%D1%8B%D1%85-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">Закон дырявых абстракций</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0">Замещение метода</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D1%82%D0%B8%D0%BF%D0%B0">Инвариант типа</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Инициализация</a></li>
		<li><a href="#%D0%B8%D0%BD%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82-%D0%B8-%D0%B4%D0%B5%D0%BA%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%82">Инкремент и декремент</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%86%D0%B8%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Инстанциирование</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%B0">Инструкции выбора</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Инструкции управления</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D1%86%D0%B8%D0%BA%D0%BB%D0%BE%D0%B2">Инструкции циклов</a></li>
		<li><a href="#%D0%B8%D0%BD%D1%82%D0%B5%D0%B3%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F-%D1%81%D1%80%D0%B5%D0%B4%D0%B0-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">Интегрированная среда разработки</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B3%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D0%B8-%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D0%B8">Исключения, гарантии безопасности</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Исключения, обработка</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%BE%D0%B9-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8">Использование параметров командной строки</a></li>
		<li><a href="#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B5%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0">Использование препроцессора</a></li>
		<li><a href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Итераторы (основные понятия, использование)</a></li>
		<li><a href="#%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B0%D0%B4%D0%B0%D0%BF%D1%82%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5">Итераторы адаптирующие</a></li>
		<li><a href="#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-%D0%B8-%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%D1%8B">Классы и экземпляры</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-extern">Ключевое слово extern</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-override">Ключевое слово override</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-template-%D0%B8-typename">Ключевое слово template и typename</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-this">Ключевое слово this</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-using">Ключевое слово using</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-virtual">Ключевое слово virtual</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2%D1%8B%D0%B5-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D1%8B-%D0%B8-%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4">Кодовые таблицы и юникод</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F">Композиция</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C">Константность</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80">Конструктор</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Конструктор копирования</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D0%B2-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5">Контейнеры (в стандартной библиотеке)</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D1%8B-%D0%BE%D1%81%D0%BD%D0%BE%D0%BD%D1%8B%D0%B5-%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F">Контейнеры (осноные понятия)</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2">Копирование объектов</a></li>
		<li><a href="#%D0%BB%D0%BE%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Логирование</a></li>
		<li><a href="#%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81%D1%8B">Макросы</a></li>
		<li><a href="#%D0%BC%D0%B0%D0%BD%D0%B8%D0%BF%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B-%D0%B8-%D0%B8%D1%85-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Манипуляторы и их использование</a></li>
		<li><a href="#%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D0%BD%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE">Машинное слово</a></li>
		<li><a href="#%D0%BC%D0%B5%D1%82%D0%BE%D0%B4">Метод</a></li>
		<li><a href="#%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8">Модель памяти</a></li>
		<li><a href="#%D0%BD%D0%BE%D0%BB%D1%8C">Ноль</a></li>
		<li><a href="#%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-scope">Область видимости (scope)</a></li>
		<li><a href="#%D0%BE%D0%B1%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Обобщенное программирование</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B2%D1%85%D0%BE%D0%B4%D0%BD%D1%8B%D1%85-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Обработка входных данных</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B">Обработка ошибок (методы)</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">Объект</a></li>
		<li><a href="#%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Объявление</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80">Оператор</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Оператор присваивания</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B---%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D1%8B">Операторы - приоритеты</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5">Операторы арифметические</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B1%D0%B8%D1%82%D0%BE%D0%B2%D1%8B%D0%B5">Операторы битовые</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B2%D1%8B%D0%B2%D0%BE%D0%B4%D0%B0-%D0%B8-%D0%B2%D0%B2%D0%BE%D0%B4%D0%B0">Операторы вывода и ввода</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Операторы доступа</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5">Операторы логические</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F">Операторы сравнения</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D1%83%D0%BD%D0%B0%D1%80%D0%BD%D1%8B%D0%B5---%D0%BF%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%B0%D1%8F-%D0%B8-%D0%BF%D0%BE%D1%81%D1%82%D1%84%D0%B8%D0%BA%D1%81%D0%BD%D0%B0%D1%8F-%D1%84%D0%BE%D1%80%D0%BC%D1%8B">Операторы унарные - префиксная и постфиксная формы</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0">Операторы, перегрузка</a></li>
		<li><a href="#%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Определение</a></li>
		<li><a href="#%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D1%87%D0%B8%D0%BA">Отладчик</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Память динамическая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F">Память статическая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%81%D1%82%D0%B5%D0%BA%D0%BE%D0%B2%D0%B0%D1%8F">Память стековая</a></li>
		<li><a href="#%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D0%B2-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B5">Память, работа в стандартной библиотеке</a></li>
		<li><a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F">Переменная</a></li>
		<li><a href="#%D0%BF%D0%BE%D0%BB%D0%B5">Поле</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2">Порядок байтов</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5">Потоки стандартные</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%8B%D0%B5">Потоки строковые</a></li>
		<li><a href="#%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%B8-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5">Потоки файловые</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D1%83">Программирование по контракту</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D1%8F%D1%89%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Производящая функция</a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D1%81%D1%82%D0%B2%D0%B0-%D0%B8%D0%BC%D0%B5%D0%BD-namespace">Пространства имен (namespace)</a></li>
		<li><a href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D0%BD%D0%B8%D0%BC-%D1%82%D0%B8%D0%BF%D0%B0">Псевдоним типа</a></li>
		<li><a href="#%D0%BF%D1%81%D0%B5%D0%B2%D0%B4%D0%BE%D1%81%D0%BB%D1%83%D1%87%D0%B0%D0%B9%D0%BD%D1%8B%D0%B5-%D1%87%D0%B8%D1%81%D0%BB%D0%B0">Псевдослучайные числа</a></li>
		<li><a href="#%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F">Раздельная компиляция</a></li>
		<li><a href="#%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F">Рекурсия</a></li>
		<li><a href="#%D1%81%2B%2B-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-%D1%81">С++ (общие сведения, отношение с с)</a></li>
		<li><a href="#%D1%81%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Связывание</a></li>
		<li><a href="#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Специализация</a></li>
		<li><a href="#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0">Ссылка</a></li>
		<li><a href="#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F">Статическая переменная</a></li>
		<li><a href="#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D1%87%D0%BB%D0%B5%D0%BD-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0">Статический член (класса)</a></li>
		<li><a href="#%D1%81%D1%82%D0%B5%D0%BA-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%BE%D0%B2">Стек вызовов</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%B0%D0%B6%D0%B8-%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Стражи включения</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D1%81-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-%D0%B8-%D0%BB%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D1%8B-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Строки (с-строки) и литералы, обработка</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8-std%3A%3Astring-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0">Строки std::string, обработка</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0">Структура</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Структура данных</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B3%D1%80%D0%B0%D1%84">Структура данных «граф»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">Структура данных «дерево»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BA%D0%BE%D1%80%D1%82%D0%B5%D0%B6">Структура данных «кортеж»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2">Структура данных «массив»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B4%D0%B2%D1%83%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9">Структура данных «список двусвязный»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%BE%D0%B4%D0%BD%D0%BE%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9">Структура данных «список односвязный»</a></li>
		<li><a href="#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D1%85%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0">Структура данных «хеш-таблица»</a></li>
		<li><a href="#%D1%82%D0%B5%D0%BA%D1%81%D1%82-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D1%8B-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8">Текст программы, комментарии</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-pod">Тип pod</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-void">Тип void</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9">Тип вещественный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B2%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9">Тип встроенный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Тип данных</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85---%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%B2%D1%8B%D0%B1%D0%BE%D1%80%D0%B0">Тип данных - принципы выбора</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D1%8B%D0%B9">Тип копируемый</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9">Тип логический</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Тип перечисление</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9">Тип символьный</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8">Тип стандартной библиотеки</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF-%D1%86%D0%B5%D0%BB%D1%8B%D0%B9">Тип целый</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D1%8B%D0%B5">Типов преобразования неявные</a></li>
		<li><a href="#%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%8F%D0%B2%D0%BD%D1%8B%D0%B5">Типов преобразования явные</a></li>
		<li><a href="#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C">Указатель</a></li>
		<li><a href="#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C-%D0%BD%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8E">Указатель на функцию</a></li>
		<li><a href="#%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BE%D0%BC">Управление доступом</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%82%D0%BE%D1%80-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82">Функтор (функциональный объект)</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Функция</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F---%D0%BF%D0%B5%D1%80%D0%B5%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0">Функция - перегрузка</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F---%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0-%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2-%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%82-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Функция - передача параметров, возврат значения</a></li>
		<li><a href="#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-main">Функция main</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD---%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B">Шаблон - параметры</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F">Шаблонная функция</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9-%D1%82%D0%B8%D0%BF">Шаблонный тип</a></li>
		<li><a href="#abi">ABI</a></li>
		<li><a href="#pimpl">PIMPL</a></li>
		<li><a href="#raii">RAII</a></li>
		<li><a href="#ref-qualifiers-for-%2Athis">Ref-qualifiers for *this</a></li>
		<li><a href="#singleton">Singleton</a></li>
		<li><a href="#std%3A%3Abitset">std::bitset</a></li>
		<li><a href="#std%3A%3Aforward">std::forward</a></li>
		<li><a href="#std%3A%3Amove">std::move</a></li>
		<li><a href="#std%3A%3Ashared_ptr">std::shared_ptr</a></li>
		<li><a href="#std%3A%3Aunique_ptr">std::unique_ptr</a></li>
		<li><a href="#std%3A%3Aweak_ptr">std::weak_ptr</a></li>
		<li><a href="#%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BB%D0%B0%D1%81%D1%81">Абстрактный класс</a></li>
		<li><a href="#%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2-%D0%B2%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">Виртуальный вызов, виртуальные функции</a></li>
		<li><a href="#%D0%B4%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC">Динамический полиморфизм</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80%D1%8B">Зависимости, пакетные менеджеры</a></li>
		<li><a href="#%D0%B7%D0%B0%D0%BC%D0%B5%D1%80%D1%8B-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8">Замеры времени</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-final">Ключевое слово final</a></li>
		<li><a href="#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-mutable">Ключевое слово mutable</a></li>
		<li><a href="#%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B9">Конструктор перемещающий</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-generic">Лямбды, generic</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82">Лямбды, захват</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Лямбды, использование</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Лямбды, общие сведения</a></li>
		<li><a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">Лямбды, хранение</a></li>
		<li><a href="#%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Множественное наследование</a></li>
		<li><a href="#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5">Наследование (в языке)</a></li>
		<li><a href="#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Наследование (ограничение доступа)</a></li>
		<li><a href="#%D0%BE%D0%BE%D0%BF-%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B">ООП, базовые принципы</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BA-%D1%87%D0%BB%D0%B5%D0%BD%D1%83-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C">Оператор "доступ к члену через указатель"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%B7%D0%B0%D0%BF%D1%8F%D1%82%D0%B0%D1%8F">Оператор "запятая"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA-%D1%82%D0%B8%D0%BF%D1%83">Оператор "приведение к типу"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D1%80%D0%B0%D0%B7%D1%8B%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Оператор "разыменование"</a></li>
		<li><a href="#%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80-%D0%BF%D1%80%D0%B8%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B0%D1%8E%D1%89%D0%B8%D0%B9">Оператор присваивания перемещающий</a></li>
		<li><a href="#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%89%D0%B5%D0%BD%D0%B8%D0%B5">Перемещение</a></li>
		<li><a href="#%D0%BF%D0%BE%D0%B4%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9-%D0%BA%D1%80%D0%B8%D1%82%D0%B5%D1%80%D0%B8%D0%B9">Подстановочный критерий</a></li>
		<li><a href="#%D0%B2%D1%8B%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Выравнивание</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%B4%D1%83%D0%BF%D1%80%D0%B5%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Предупреждения</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%B2%D1%8B%D1%88%D0%B0%D1%8E%D1%89%D0%B5%D0%B5">Преобразование повышающее</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BD%D0%B8%D0%B6%D0%B0%D1%8E%D1%89%D0%B5%D0%B5">Преобразование понижающее</a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-bit_cast">Приведение типа bit_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-const_cast">Приведение типа const_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-dynamic_cast">Приведение типа dynamic_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-reinterpret_cast">Приведение типа reinterpret_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%B0-static_cast">Приведение типа static_cast<></a></li>
		<li><a href="#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%BD%D0%B8%D1%87%D1%82%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Производные объекты, конструирование и уничтожение</a></li>
		<li><a href="#%D0%BF%D1%80%D1%8F%D0%BC%D0%B0%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0">Прямая передача</a></li>
		<li><a href="#%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0-%D0%BF%D1%80%D0%B0%D0%B2%D0%B0%D1%8F">Ссылка (правая)</a></li>
		<li><a href="#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Шаблон, специализация</a></li>
	</ol>
</details>

<hr style="width:25%;text-align:left;margin-left:0">

## l-value и r-value

`l-value` - это выражение, которое имеет идентификатор и адрес в памяти, куда можно присвоить значение.

`r-value` - это выражение, которое не имеет адреса в памяти и часто используется как значение.

### Примеры
```C++
int x = 5; // x - l-value, 5 - r-value
```

<hr style="width:25%;text-align:left;margin-left:0">

## nullptr, NULL, 0

`nullptr` - введен в стандарте C++11 и представляет собой безопасную замену для `NULL` и `0` в указателях. `nullptr` имеет тип `std::nullptr_t` и может быть присвоен любому указателю.

`0` - также используется для представления нулевого указателя.

`NULL` - это макрос, обычно определенный как `#define NULL 0`, который используется для представления нулевого указателя (наследство из C -> не используем).

В C++11 и более поздних стандартах рекомендуется использовать `nullptr` вместо `NULL` и `0`, так как `nullptr` имеет явный тип и предотвращает некоторые ошибки, связанные с неправильным использованием нулевых указателей.

### Примеры
```C++
int* ptr1 = nullptr;
int* ptr2 = NULL;
int* ptr3 = 0;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм бинарного поиска

Бинарный поиск — это эффективный алгоритм поиска, который используется для нахождения позиции заданного элемента в отсортированном массиве. Принцип работы бинарного поиска заключается в последовательном делении массива на две части и сравнении искомого значения со значением элемента в середине массива.

Преимущества бинарного поиска:
* Высокая эффективность: Время выполнения бинарного поиска — `O(log n)`, где `n` — количество элементов в массиве.
* Простота реализации: Легко реализовать и отладить.

Ограничения:
* Требует отсортированного массива.
* Подходит только для последовательного доступа: Не подходит для структур данных с произвольным доступом, таких как связные списки.

Сложность по времени: `O(log n)`

Сложность по памяти: `O(1)`

### Примеры
```C++
std::vector<int> vec = { 1, 3, 5, 7, 9, 11, 13 }; // Вектор уже отсортирован
int target = 7; // искомое значение
std::binary_search(vec.begin(), vec.end(), target) // true - найден, false - нет
```

<hr style="width:25%;text-align:left;margin-left:0">

## Алгоритм сортировки, основные характеристики

Алгоритмы сортировки позволяют упорядочить данные для эффективного доступа и обработки. Основные характеристики алгоритмов сортировки включают сложность по времени и памяти, стабильность и адаптивность.

### Примеры
Пузырьковая сортировка (Bubble Sort)
* Сложность по времени: `O(n^2)` в худшем и среднем случае, `O(n)` в лучшем случае (если массив уже отсортирован).
* Сложность по памяти: `O(1)`, так как не требует дополнительной памяти.
* Стабильность: Стабильный (не меняет порядок равных элементов).
* Адаптивность: Адаптивен (способность алгоритма работать быстрее на частично отсортированных данных).

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритм хеширования

Это функция, преобразующая входные данные произвольной длины в строку фиксированной длины, часто называемую хеш-кодом. Полученный хеш обычно имеет меньший размер, чем исходные данные.

Хеширование используется во многих областях информационной безопасности, включая проверку целостности данных и аутентификацию. Алгоритмы хеширования позволяют распознавать изменённые данные, они применяются в базах данных для более эффективного доступа к данным, в цифровых подписях, блокчейнах и хранении паролей.

Свойства:
* Детерминированность: одни и те же входные данные всегда приводят к тому же хеш-коду.
* Быстрое вычисление: хеш можно вычислить относительно быстро для любого объема входных данных.
* Эффект лавины: небольшое изменение входных данных вызывает существенное изменение результата хеширования.
* Необратимость: невозможно восстановить исходные данные по их хеш-коду.
* Стойкость к коллизиям: сложность нахождения второго входного значения, которое имеет такой же хэш, как и данное входное значение (слабая/сильная).

### Примеры
```C++
std::unordered_map<std::string, int> umap;

// Вставка элементов в unordered_map
umap["apple"] = 2;
umap["banana"] = 4;
umap["orange"] = 3;

// Альтернативный способ вставки с использованием метода insert
umap.insert({ "pear", 5 });
```

<hr style="width:25%;text-align:left;margin-left:0">

##  Алгоритмы стандартной библиотеки

Стандартная библиотека - коллекция классов, функций, макросов и констант.

Находятся в `<algorithm>`.

Основные категории алгоритмов:
* Алгоритмы поиска и проверки.
* Алгоритмы сортировки и упорядочивания.
* Алгоритмы модификации.
* Алгоритмы копирования и перемещения.
* Алгоритмы генерации и удаления.
* Алгоритмы численных операций.

### Примеры
```C++
int x = 1;
int y = 2;
std::min(x, y); // 1
std::max(x, y); // 2

std::vector<int> vec = { 1, 2, 3, 4, 5 };
std::find(vec.begin(), vec.end(), 3); // поиск индекса эллемента '3'

std::binary_search(vec.begin(), vec.end(), 3); // true - '3' найдено, false - '3' не найдено

std::vector<int> vec = {5, 3, 1, 4, 2};
std::sort(vec.begin(), vec.end()); // vec = { 1, 2, 3, 4, 5 }

std::reverse(vec.begin(), vec.end()); // vec = { 5, 4, 3, 2, 1 }

std::replace(vec.begin(), vec.end(), 1, 9); // vec = { 5, 4, 3, 2, 9 }

std::vector<int> vec_copy(5);
std::copy(vec.begin(), vec.end(), vec_copy.begin()); // vec_copy = { 5, 4, 3, 2, 9 }

std::vector<int> vec_move(5);
std::move(vec_copy.begin(), vec_copy.end(), vec_move.begin()); // vec_move = { 5, 4, 3, 2, 9 } vec_copy = { }
```

<hr style="width:25%;text-align:left;margin-left:0">

##  Алфавит и идентификатор

Алфавит C++ состоит из следующих символов:

1. Буквы:
* Заглавные латинские буквы: `A-Z`.
* Строчные латинские буквы: `a-z`.
* Цифры: `0-9`.

2. Специальные символы:
* Символы пунктуации: `+`, `-`, `*`, `/`, `%`, `=`, `&`, `|`, `!`, `^`, `~`, `<`, `>`, `?`, `:`, `;`, `,`, `.`, `@`, `#`, `$`, `_`
* Скобки и операторы: `()`, `{}`, `[]`, `::`, `->`, `.`

3. Пробелы и управляющие символы:
* Пробел, табуляция и другие символы управления, такие как `\n` (новая строка), `\t` (табуляция) и т.д.
* Идентификаторы — это имена, которые программист присваивает переменным, функциям, классам, объектам и другим элементам программы. Правила именования идентификаторов в C++:

Начало идентификатора:
* Должен начинаться с буквы (заглавной или строчной) или символа подчеркивания `_`
* Не может начинаться с цифры.

Содержимое идентификатора:
* Может содержать буквы, цифры и символы подчеркивания.
* Пробелы и специальные символы (кроме `_`) не допускаются.

Регистр имеет значение:
* C++ различает идентификаторы, записанные в разном регистре. Например, `Variable` и `variable` считаются разными идентификаторами.

Ключевые слова:
* Идентификаторы не могут совпадать с ключевыми словами языка C++ (например, `int`, `class`, `return` и т.д.).

Стиль именования:
* Стиль именования может следовать соглашениям, принятым в проекте или команде. Например, CamelCase, snake_case и т.д.

### Примеры
```C++
int myVariable;       // допустимый идентификатор
int _my_variable;     // допустимый идентификатор
int variable2;        // допустимый идентификатор
int Variable;         // допустимый идентификатор, отличается от "variable"
int 2variable;        // недопустимый идентификатор, начинается с цифры
int my-variable;      // недопустимый идентификатор, содержит дефис
int int;              // недопустимый идентификатор, совпадает с ключевым словом
```

<hr style="width:25%;text-align:left;margin-left:0">

## Арифметика указателей

К указателю можно прибавлять число, тогда он станет указывать на следующий элемент(если он указывал на элемент массива). Если указатель вышел за пределы массива, то результат разыменования не определён. Можно вычитать указатель из указателя в пределах одного массива, результатом будет количество элементов между ними.

### Примеры
```C++
int arr[] = { 1, 2, 3, 4, 5 };
int *ptr = arr; // Указатель на начало массива arr

std::cout << "Element 1: " << *ptr << std::endl; // Вывод первого элемента

++ptr; // Перемещение указателя на следующий элемент
std::cout << "Element 2: " << *ptr << std::endl; // Вывод второго элемента

ptr += 2; // Перемещение указателя на два элемента вперед
std::cout << "Element 4: " << *ptr << std::endl; // Вывод четвертого элемента

--ptr; // Перемещение указателя на 1 элемент назад
std::cout << "Element 3: " << *ptr << std::endl; // Вывод третьего элемента
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД

Абстрактный Тип Данных - интерфейс, описывающий набор операций над типом данных, но не то как они реализованы(логику использования). Операции, описанные в любом АТД - создание, уничтожение, копирование. АТД скрывает детали реализации, лишь предоставляя интерфейс.

### Примеры
* Стек
* Очередь
* Двусвязный список

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «cтек» и варианты реализации

Абстрактный тип данных "стек" реализует структуру данных с наиболее последним приходом, первым на выход (LIFO - Last-In, First-Out). Элементы добавляются на вершину стека и удаляются с вершины.

Основные операции, которые определяют интерфейс стека, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `push` - добавление элемента в конец стека.
* `pop` - удаление и возвращение элемента с конца стека.
* `top` или `peek` - возвращение элемента с конца стека без удаления.
* `isEmpty` - проверка, пуст ли стек.
* `size` - получение числа элементов в стеке.

Реализация на основе массива и связанного списка.
В стандартной библиотеке реализован на deque(дэк) и представлен в виде `std::stack<T>`.

<hr style="width:25%;text-align:left;margin-left:0">АТД «дэк» и варианты реализации

## АТД «дэк» и варианты реализации

Двусвязная очередь - это абстрактный тип данных, представляет собой структуру данных, которая поддерживает добавление и удаление элементов с обоих концов.

Реализация на основе массива и двусвязанного списка.

Основные операции, которые определяют интерфейс дэка, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `push_back` - добавление элемента в конец дэка.
* `push_front` - добавление элемента в начало дэка.
* `pop_back` - удаление и возвращение элемента с конца дэка.
* `pop_front` - удаление и возвращение элемента с начала дэка.
* `top` или `peek` - возвращение элемента с конца дэка без удаления.
* `isEmpty` - проверка, пуст ли дэк.
* `size` - получение числа элементов в дэке.

В стандартной библиотеке - `std::deque<T>`.

### Примеры
```C++
std::deque<int> myDeque;

myDeque.push_back(10); // Добавление в конец
myDeque.push_front(5); // Добавление в начало

// Доступ к элементам "дэка"
std::cout << "Front element: " << myDeque.front() << std::endl; // '5'
std::cout << "Back element: " << myDeque.back() << std::endl; // '10'

myDeque.pop_front(); // Удаление из начала
myDeque.pop_back(); // Удаление из конца
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «массив» и варианты реализации

Типы:
* Статический массив: Фиксированный размер, быстрый доступ к элементам и вставка.
* Динамический массив: Размер меняется во время выполнения программы, быстрый доступ к элементам, но вставка при расширении занимает дольше времени.

Основные операции, которые определяют интерфейс массива, включают:
* `operator[]` - получение/запись эллемента по индексу.
* `empty` - проверка, пуст ли массив.
* `size` - получение числа элементов в массивe.

В стандартной библиотеке представлены в виде `std::array<T>` и `std::vector<T>`.

### Примеры
```C++
std::vector<int> vec;

// Добавляем элементы в конец вектора
vec.push_back(1);
vec.push_back(2);

// Выводим элементы вектора
for (int i = 0; i < vec.size(); ++i) {
    std::cout << "Element " << i << ": " << vec[i] << std::endl;
}

vec[1] = 5; // Изменяем значение элемента по индексу 1 на '5'

// --------------------------------------------------------------

std::array<int, 5> arr = { 1, 2, 3, 4, 5 };

// Выводим элементы массива
std::cout << "Array elements:" << std::endl;
for (int i = 0; i < arr.size(); ++i) {
    std::cout << "Element " << i << ": " << arr[i] << std::endl;
}

arr[1] = 6; // Изменяем значение элемента по индексу 1 на '6'
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «матрица» и варианты реализации

Это абстрактный тип данных, описывающий набор операций над элементами, расположенными в виде таблицы: создание, уничтожение, копирование, доступ к элементу по индексу, получение количества столбцов, получение количества строк.

Можно реализовать через массив с приведенным индексом, или массивы одинаковой длины в другом массиве.

### Примеры
```C++
std::vector<std::vector<int>> mat = {
    { 5, 8, 2 },
    { 8, 3, 1 },
    { 5, 3, 9 }
};

std::array<std::array<int, 3>, 3> matrix = {
    { 5, 8, 2 },
    { 8, 3, 1 },
    { 5, 3, 9 }
};
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «множество» и варианты реализации

Это структура данных, которая содержит уникальные элементы без какого-либо порядка.

Можно реализовать через массив с проверкой на дубликаты или хэш-функцию.

Основные операции, которые определяют интерфейс множества, включают:
* `insert` - вставка эллемента во множество.

В стандартной библиотеке представлена в виде `std::set<T>`.

### Примеры
```C++
std::set<int> mySet;

// Вставляем элементы в множество
mySet.insert(3);
mySet.insert(1);
mySet.insert(5);
mySet.insert(2);
mySet.insert(1); // Этот элемент не будет добавлен, так как '1' уже есть во множестве
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «очередь с приоритетом» и варианты реализации

Это структура данных, которая хранит элементы с определенным приоритетом. Элемент с более высоким приоритетом извлекается раньше, чем элементы с более низким приоритетом.

Можно реализовать через массив, вставляя эллемент в определенное место.

В стандартной библиотеке представлена в виде `std::priority_queue<T>`.

### Примеры
```C++
std::priority_queue<int> pq;

pq.push(30); // низкий приоритет
pq.push(100); // высокий приоритет
pq.push(50); // средний приоритет

while (!pq.empty()) {
    std::cout << pq.top() << " ";
    pq.pop();
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «очередь» и варианты реализации

Представляет собой структуру данных, работающую по принципу FIFO (First In, First Out), что означает, что первый элемент, добавленный в очередь, будет первым извлечен из неё.

Может быть реализована несколькими способами: с использованием массивов, связных списков.

Основные операции, которые определяют интерфейс очереди, включают:
* `push` - добавление элемента в конец очереди.
* `pop` - удаление и возвращение элемента с конца очереди.
* `empty` - проверка, пуста ли очередь.
* `size` - получение числа элементов в очереди.

В стандартной библиотеке представлена в виде `std::queue<T>`.

### Примеры
```C++
std::queue<int> q;
 
q.push(0); // q = 0
q.push(1); // q = 0 1
q.push(2); // q = 0 1 2
q.push(3); // q = 0 1 2 3

q.size() // 4

q.pop(); // удаляет первый эллемент 0

q.size() // 3
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «полином» и варианты реализации

Это абстрактный тип данных, описывающий операции над многочленом.

Можно реализовать через массив, хранящий коэффициенты.

Основные операции, которые определяют интерфейс полинома, включают:
* Сложение полиномов.
* Доступ к коэффициенту по индексу.
* Умножение на число.

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «словарь» и варианты реализации

Представляет собой структуру данных, описывающую операции над набором пар типов, где один из типов является ключём, а другой - значением.

Может быть реализован несколькими способами: с использованием хэш-функции и деревом.

Основные операции, которые определяют словарь очереди, включают:
* `operator[]` - получение/запись эллемента по ключу.
* `insert` - добавление элемента в словарь.
* `erase` - удаление и элемента по ключу.
* `empty` - проверка, пустой ли словарь.
* `size` - получение числа элементов в словаре.

В стандартной библиотеке представлены в виде `std::map<T>`(сбалансированное красно-черное дерево) и `std::unordered_map<T>`(хэш-функция).

### Примеры
```C++
std::map<std::string, int> myMap;

// Добавляем элементы в map
myMap["apple"] = 5;
myMap["banana"] = 3;
myMap["orange"] = 7;

myMap.erase("apple"); // Удаляем элемент из map

// ------------------------------------------------

std::unordered_map<std::string, int> myUnorderedMap;

// Добавляем элементы в unordered_map
myUnorderedMap["apple"] = 5;
myUnorderedMap["banana"] = 3;
myUnorderedMap["orange"] = 7;

myUnorderedMap.erase("apple"); // Удаляем элемент из unordered_map
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «строка» и варианты реализации

Представляет собой структуру данных, описывающую операции над последовательностью символом.

Может быть реализована несколькими способами: массивом из символов(char'ов).

Основные операции, которые определяют строку очереди, включают:
* `operator[]` - получение/запись символа по индексу.
* `erase` - удаление и символа по индексу.
* `empty` - проверка, пустая ли строка.
* `length` - получение числа символов в строке.

В стандартной библиотеке представлена в виде `std::string`.

### Примеры
```C++
std::string str = "Hello";

str.length() // 5

str[0]; // 'H'

str.erase(0) // str = "ello"

str.empty() // false
```

<hr style="width:25%;text-align:left;margin-left:0">

## АТД «число» и варианты реализации

Представляет собой математическую абстракцию чисел и операции над ними.

В рамках программирования АТД «число» может быть представлен различными способами в зависимости от требований к точности и диапазону значений. 

Основные операции, которые определяют число очереди, включают:
* Операторы арифметических операций.
* Операторы сравнения.

В C++ представлены в виде `int`, `float`, `double` и т.д.

### Примеры
```C++
int a = 10;
float b = 3.14;
double c = 354654.34686796345;
```

<hr style="width:25%;text-align:left;margin-left:0">

## Инстанциирование

Генерация объявления функции или типа по шаблону и его аргументам. Осуществляется во время компиляции.

### Примеры
```C++
// Объявление шаблона функции
template <typename T>
T add(T a, T b)
{
    return a + b;
}

// Объявление шаблона класса
template <typename T>
class Box
{
public:
    Box(T v) : value(v) {}

private:
    T value;
};

int main()
{
    // Инстанциирование шаблонной функции с типом int
    int intResult = add<int>(3, 4);
    
    // Инстанциирование шаблонного класса с типом int
    Box<int> intBox(123);

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Диапазоны и операции над ними

Диапазон — то, над чем можно выполнить итерацию. Представлен итераторами, которые указывает на начало и конец диапазона. Конечный итератор может быть как того же типа, что и начальный, так и другого. vector и list являются диапазонами.

### ?

<hr style="width:25%;text-align:left;margin-left:0">

## Закон дырявых абстракций
Закон дырявых абстракций (Law of Leaky Abstractions) был сформулирован Джоэлем Спольски (Joel Spolsky) и гласит: "Все абстракции являются дырявыми (leaky), и, хотя они помогают нам управлять сложностью, в конечном итоге нам все равно приходится разбираться с деталями, которые они скрывают".

### Примеры
* Языки программирования высокого уровня:
Языки, такие как Python или Java, скрывают множество деталей работы с памятью и управлением ресурсами. Однако проблемы с производительностью или утечками памяти могут потребовать знания того, как язык взаимодействует с аппаратурой и операционной системой.

* Сетевые абстракции:
Программные интерфейсы для работы с сетью (например, сокеты) абстрагируют от разработчиков многие детали сетевого взаимодействия. Однако проблемы с сетью, такие как задержки, потери пакетов и перегрузки, могут привести к тому, что абстракции "протекут", и разработчики вынуждены разбираться с сетевыми проблемами напрямую.

<hr style="width:25%;text-align:left;margin-left:0">

## Итераторы адаптирующие

Итераторы-адаптеры (iterator adaptors) представляют собой специальный тип итераторов, которые изменяют или адаптируют поведение базового итератора. Они позволяют применять дополнительные операции к последовательностям, не изменяя исходные контейнеры. Стандартная библиотека C++ предоставляет несколько таких адаптеров, которые облегчают работу с итераторами.

1. `std::reverse_iterator`
Этот адаптер позволяет обходить последовательность в обратном порядке.

Пример использования:
```C++
int main()
{
    std::vector<int> vec = { 1, 2, 3, 4, 5 };

    // Создание реверс-итератора
    std::reverse_iterator<std::vector<int>::iterator> rbegin(vec.end());
    std::reverse_iterator<std::vector<int>::iterator> rend(vec.begin());

    std::cout << "Reversed vector: ";
    for (auto it = rbegin; it != rend; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

1. `std::reverse_iterator`
Этот адаптер позволяет обходить последовательность в обратном порядке.

Пример использования:
```C++
int main()
{
    std::vector<int> vec = { 1, 2, 3, 4, 5 };

    // Создание реверс-итератора
    std::reverse_iterator<std::vector<int>::iterator> rbegin(vec.end());
    std::reverse_iterator<std::vector<int>::iterator> rend(vec.begin());

    std::cout << "Reversed vector: ";
    for (auto it = rbegin; it != rend; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

2. `std::back_insert_iterator`
Этот адаптер используется для вставки элементов в конец контейнера. Он оборачивает контейнер и предоставляет итератор, который всегда указывает на конец контейнера, эффективно делая `push_back` для каждого элемента, вставленного через него.

Пример использования:
```C++
int main()
{
    std::vector<int> vec = { 1, 2, 3 };
    std::vector<int> additional = { 4, 5, 6 };

    // Создание back_insert_iterator
    std::back_insert_iterator<std::vector<int>> back_it(vec);

    // Использование копирования через итератор
    std::copy(additional.begin(), additional.end(), back_it);

    std::cout << "Vector after back insertion: ";
    for (const auto& elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

3. `std::front_insert_iterator`
Этот адаптер используется для вставки элементов в начало контейнера (например, `std::deque` или `std::list`). Он оборачивает контейнер и предоставляет итератор, который всегда указывает на начало контейнера, эффективно делая `push_front` для каждого элемента, вставленного через него.

Пример использования:
```C++
int main()
{
    std::deque<int> deq = { 1, 2, 3 };
    std::deque<int> additional = { 4, 5, 6 };

    // Создание front_insert_iterator
    std::front_insert_iterator<std::deque<int>> front_it(deq);

    // Использование копирования через итератор
    std::copy(additional.begin(), additional.end(), front_it);

    std::cout << "Deque after front insertion: ";
    for (const auto& elem : deq) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

4. `std::insert_iterator`
Этот адаптер используется для вставки элементов в произвольное место контейнера. Он оборачивает контейнер и предоставляет итератор, который указывает на позицию вставки.

Пример использования:
```C++
int main()
{
    std::vector<int> vec = { 1, 2, 3, 6, 7, 8 };
    std::vector<int> additional = { 4, 5 };

    // Создание insert_iterator
    std::insert_iterator<std::vector<int>> insert_it(vec, vec.begin() + 3);

    // Использование копирования через итератор
    std::copy(additional.begin(), additional.end(), insert_it);

    std::cout << "Vector after insertion: ";
    for (const auto& elem : vec) {
      std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Обобщенное программирование

Обобщённое программирование (Generic Programming) — это парадигма программирования, которая позволяет писать код, работающий с различными типами данных, не жертвуя производительностью и безопасностью. В C++ эта концепция реализуется с помощью шаблонов (templates).

### Примеры
```C++
template <typename T>
T add(T a, T b)
{
    return a + b;
}

int main()
{
    std::cout << "Int: " << add(1, 2) << std::endl;
    std::cout << "Double: " << add(1.1, 2.2) << std::endl;
    std::cout << "String: " << add(std::string("Hello, "), std::string("world!")) << std::endl;

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Порядок байтов

Определяет порядок, в котором байты данных хранятся в памяти.

Существует два основных типа порядка байтов:
1. Big-endian (старший байт первый)
В big-endian системе самый значимый байт (старший байт) хранится в самой младшей (первой) памяти, а наименее значимый байт (младший байт) - в последней.

Предположим, что у нас есть 32-битное значение `0x12345678`. В памяти это значение будет представлено следующим образом:
```
Адреса:  | 0x00 | 0x01 | 0x02 | 0x03 |
Значения:| 0x12 | 0x34 | 0x56 | 0x78 |
```

2. Little-endian (старший байт первый)
В little-endian системе самый значимый байт (старший байт) хранится в самой старшей памяти, а наименее значимый байт (младший байт) - в первой.

Для того же значения `0x12345678`, в little-endian системе это будет представлено следующим образом:
```
Адреса:  | 0x00 | 0x01 | 0x02 | 0x03 |
Значения:| 0x78 | 0x56 | 0x34 | 0x12 |
```

<hr style="width:25%;text-align:left;margin-left:0">

## Функтор (функциональный объект)

Функтор (functor), или функциональный объект, представляет собой объект класса, который может быть вызван как функция. Это достигается перегрузкой оператора вызова функции `operator()` в классе. Функторы полезны для передачи логики в качестве параметров в алгоритмы стандартной библиотеки и могут хранить состояние между вызовами.

### Преимущества использования функтора
* Сохранение состояния: Функторы могут сохранять состояние между вызовами, что невозможно с обычными функциями.
* Инкапсуляция логики: Логика может быть инкапсулирована внутри класса, что делает код более организованным и повторно используемым.
* Совместимость с алгоритмами STL: Функторы широко используются в алгоритмах стандартной библиотеки, таких как `std::sort`, `std::for_each` и других.

### Пример использования функтора
```C++
// Определение класса-функтора
class Square
{
public:
    // Перегрузка оператора ()
    int operator()(int x) const
    {
        return x * x;
    }
};

int main()
{
    Square square; // Создание объекта функтора
    int value = 5;

    std::cout << "Square of " << value << " is " << square(value) << std::endl; // Вызов функтора как функции

    return 0;
}
```

### Функторы с состоянием
```C++
class Multiplier
{
private:
    int factor;
public:
    // Конструктор для инициализации коэффициента
    Multiplier(int f) : factor(f) {}

    // Перегрузка оператора ()
    int operator()(int x) const
    {
        return x * factor;
    }
};

int main()
{
    Multiplier mult(3); // Создание объекта функтора с коэффициентом 3
    int value = 5;
    std::cout << value << " multiplied by factor is " << mult(value) << std::endl; // Вызов функтора как функции

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Зависимости, пакетные менеджеры

Зависимость - подключаемый модуль(библиотека, фреймворк или файл), который необходим для работы программы. Так как для использования зависимости иногда приходится компилировать самому, существуют пакетные менеджеры, такие как `conan` и `vcpkg`, которые либо находят уже нужную скомпилированную версию, либо собирают ее за пользователя.

<hr style="width:25%;text-align:left;margin-left:0">

## Замеры времени

Замеры времени проводят для измерения производительности и выявления бутылочных горлышек - мест, которые тормозят работу всей программы. Абсолютные замеры времени не информативны, нужно замерять время несколько раз в одних и тех же условиях, после чего обрабатывать полученную информацию и извлекать необходимые выводы. Для измерения промежутков времени можно использовать библиотеки `ctime`(устаревшая и менее точная) и `chrono`.

### Пример
```C++
#include <chrono>

int main()
{
    std::chrono::time_point<std::chrono::high_resolution_clock> startPoint; // Создаем начальную и конечную точку во времени
    std::chrono::time_point<std::chrono::high_resolution_clock> endPoint;
    
    startPoint = std::chrono::high_resolution_clock::now(); // Отмечаем точку во времени
    // Совершаем действие, которое хотим замерить
    endPoint = std::chrono::high_resolution_clock::now();
    std::cout << std::chrono::duration_cast<std::chrono::nanoseconds>(endPoint - startPoint) << '\n'; // Выводим разницу между началом и концом
    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Ключевое слово final

Спецификатор final обозначает, что виртуальную функцию нельзя перезаписать в производном классе или что от класса нельзя унаследоваться.

### Пример
```C++
class A
{
public:
    virtual void func() final;
};

class B : public A
{
public:
    void func() override // Ошибка: нельзя перезапистать виртуальную функцию со спецификатором final
    {
        //.....
    }
};

//---------------------------------------

class C final
{
    //.........
};

class D : public C // Ошибка: нельзя унаследоваться от класса со спецификатором final
{
    //.........
};
```

<hr style="width:25%;text-align:left;margin-left:0">

## Ключевое слово mutable

Ключевое слово `mutable` позволяет менять поле, к которому оно примененно, внутри const метода.

### Пример
```C++
class Example
{
public:
    //...
    
    void Check() const
    {   
        b = 2; // разрешено
        a = 2; // запрещено
    }
    
private:
    int a;
    mutable int b;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Конструктор перемещающий

Конструктор перемещающий - перегрузка конструктор, который в качестве аргумента принимает rvalue ссылку на тип. Использует семантику перемещения для инициализации объекта значением другого.

### Пример
```C++
class Example
{
public:
    //.....
    Example(Example&& copy)
    {
        std::swap(data_, copy.data_);
    }
    
private:
    std::vector<int> data_;
};

int main()
{
    Example a();
    //....
    Example b(std::move(a)); // Вызывается перемещающий конструктор, после его работы тип a невалиден,а тип b имеет значение типа a
}

```

<hr style="width:25%;text-align:left;margin-left:0">

## Лямбды, generic

Появились в C++20. Можно создать лямбда-выражение, которое будет работать с различными типами данных, а не только с конкретными типами.

### Пример
```C++
template <typename T>
void process(T value)
{
    auto lambda = [](const T& val) {
        std::cout << "Value: " << val << std::endl;
    };

    /* или  auto lambda = [](const auto& val) {
                std::cout << "Value: " << val << std::endl;
    };                                                     */
    
    lambda(value);
}

int main()
{
    process(5); // Выведет "Value: 5"
    process("Hello"); // Выведет "Value: Hello"
    
    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Лямбды, захват

Лямбда-выражения могут захватывать переменные из своей окружающей среды. Захват может быть сделан по значению или по ссылке.

### Пример
```C++
int main()
{
    int x = 10;
    int y = 20;

    auto capture_by_value = [x, y]() {
        return x + y;
    };

    auto capture_by_reference = [&x, &y]() {
        return x + y;
    };

    x = 15;
    y = 25;

    std::cout << "Capture by value: " << capture_by_value() << std::endl;  // 30 (10 + 20)
    std::cout << "Capture by reference: " << capture_by_reference() << std::endl; // 40 (15 + 25)

    return 0;
}
```

Лямбда может захватывать все переменные из окружающей области видимости, используя `=` для захвата по значению или `&` для захвата по ссылке.

### Пример
```C++
int main()
{
    int x = 5;
    int y = 10;

    // Захват всех переменных по значению
    auto capture_all_by_value = [=]() {
        return x + y;
    };

    // Захват всех переменных по ссылке
    auto capture_all_by_reference = [&]() {
        return x + y;
    };

    x = 20;
    y = 30;

    std::cout << "Capture all by value: " << capture_all_by_value() << std::endl;  // 15 (5 + 10)
    std::cout << "Capture all by reference: " << capture_all_by_reference() << std::endl; // 50 (20 + 30)

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Лямбды, использование

Они полезны для создания временных функций, которые могут быть переданы в качестве параметров другим функциям или сохранены для последующего использования.

Cмотреть <a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-generic">Лямбды, generic</a>, <a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B7%D0%B0%D1%85%D0%B2%D0%B0%D1%82">Лямбды, захват</a>, <a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Лямбды, использование</a>, <a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D1%81%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Лямбды, общие сведения</a>, <a href="#%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B-%D1%85%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5">Лямбды, хранение</a>.

<hr style="width:25%;text-align:left;margin-left:0">

## Лямбды, общие сведения

Лямбда-выражения - это анонимные функции, которые могут захватывать переменные из своей окружающей среды. Они позволяют создавать функции на месте и передавать их как параметры, возвращать их из функций или хранить в переменных. Они могут хранить захваченные переменные, что делает их полезными для написания компактного и выразительного кода.

Лямбда-выражение состоит из трех основных частей:
* Захват (capture list)
* Параметры (parameter list)
* Тело (body)
```[захват] (параметры) -> возвращаемый_тип { тело }```

### Пример
```C++
int main()
{
    auto add = [](int a, int b) -> int {
        return a + b;
    };

    std::cout << "3 + 4 = " << add(3, 4) << std::endl; // Вывод: 3 + 4 = 7
    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Лямбды, хранение

Лямбды могут быть сохранены в переменных, функторах или стандартных контейнерах, таких как `std::function`. `std::function` является обобщенным типом, который может хранить лямбды, функции и функторы с определенным типом подписи.

### Пример
```C++
int main()
{
    int a = 5;
    int b = 3;

    // Лямбда сохраненная в переменную
    auto multiply = [a, b]() {
        return a * b;
    };

    // Лямбда сохраненная в std::function
    std::function<int(int, int)> add = [](int x, int y) {
        return x + y;
    };

    std::cout << "Multiply: " << multiply() << std::endl;  // Вывод: 15 (5 * 3)
    std::cout << "Add: " << add(4, 2) << std::endl;  // Вывод: 6 (4 + 2)

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Множественное наследование

Позволяет классу наследовать от более чем одного базового класса. Это мощная возможность, но она может привести к сложностям, таким как конфликт имен и проблема ромбовидного наследования (Diamond Problem).

### Примеры
```C++
class Base1
{
public:
    void display1() const
    {
        std::cout << "Base1 display1" << std::endl;
    }
};

class Base2
{
public:
    void display2() const
    {
        std::cout << "Base2 display2" << std::endl;
    }
};

class Derived : public Base1, public Base2
{
public:
    void displayDerived() const
    {
        std::cout << "Derived display" << std::endl;
    }
};

int main()
{
    Derived d;

    d.display1();      // Метод из Base1
    d.display2();      // Метод из Base2
    d.displayDerived(); // Метод из Derived

    return 0;
}
```

### Проблемы множественного наследования
* Конфликт имен:
Если два базовых класса имеют методы с одинаковыми именами, производный класс должен явно указывать, какой метод вызывать, чтобы избежать неоднозначности.
```C++
class Base1
{
public:
    void show() const
    {
        std::cout << "Base1 show" << std::endl;
    }
};

class Base2
{
public:
    void show() const
    {
        std::cout << "Base2 show" << std::endl;
    }
};

class Derived : public Base1, public Base2
{
public:
    void display() const
    {
        Base1::show(); // Явный вызов метода Base1
        Base2::show(); // Явный вызов метода Base2
    }
};

int main()
{
    Derived d;

    d.display();

    return 0;
}
```

* Проблема ромбовидного наследования (Diamond Problem):
Проблема ромбовидного наследования возникает, когда два базовых класса наследуют от одного общего базового класса, а производный класс наследует от этих двух базовых классов. В результате в производном классе может оказаться несколько копий членов общего базового класса.
```C++
class Base
{
public:
    void show() const
    {
        std::cout << "Base show" << std::endl;
    }
};

class Derived1 : public Base {};
class Derived2 : public Base {};
class Final : public Derived1, public Derived2 {};

int main()
{
    Final f;

    // f.show(); // Ошибка: неоднозначность, две копии Base

    return 0;
}
```

Решение проблемы ромбовидного наследования с помощью виртуального наследования:
Для решения проблемы ромбовидного наследования в C++ используется виртуальное наследование. Виртуальное наследование гарантирует, что будет только одна копия членов общего базового класса.
```C++
class Base
{
public:
    void show() const
    {
        std::cout << "Base show" << std::endl;
    }
};

class Derived1 : virtual public Base {};
class Derived2 : virtual public Base {};
class Final : public Derived1, public Derived2 {};

int main()
{
    Final f;

    f.show(); // Нет ошибки, так как только одна копия Base

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Наследование (в языке)

Наследование позволяет одному классу (производному или подклассу) унаследовать свойства и методы другого класса (базового или суперкласса).

Все остальное описано в <a href="#%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Наследование (ограничение доступа)</a> и <a href="#%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Множественное наследование</a>.

<hr style="width:25%;text-align:left;margin-left:0">

## Наследование (ограничение доступа)

Наследование позволяет одному классу (производному или подклассу) унаследовать свойства и методы другого класса (базового или суперкласса). При наследовании важно учитывать уровни доступа: `public`, `protected` и `private`. Эти уровни определяют, каким образом члены базового класса будут доступны в производном классе и за его пределами.

### Примеры
1. Public наследование (открытое наследование).
* Открытые (`public`) члены базового класса остаются открытыми.
* Защищенные (`protected`) члены базового класса остаются защищенными.
* Закрытые (`private`) члены базового класса недоступны напрямую, но они могут быть доступны через публичные или защищенные методы базового класса.

```C++
class Base
{
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class Derived : public Base
{
public:
    void access()
    {
        publicVar = 1;     // Доступен
        protectedVar = 2;  // Доступен
        // privateVar = 3; // Недоступен
    }
};
```

2. Protected наследование (защищенное наследование).
* Открытые (`public`) члены базового класса становятся защищенными.
* Защищенные (`protected`) члены базового класса остаются защищенными.
* Закрытые (`private`) члены базового класса недоступны напрямую.

```C++
class Base
{
public:
    int publicVar;

protected:
    int protectedVar;
	
private:
    int privateVar;
};

class Derived : protected Base
{
public:
    void access()
    {
        publicVar = 1;     // Доступен как защищенный член
        protectedVar = 2;  // Доступен
        // privateVar = 3; // Недоступен
    }
};

int main()
{
    Derived obj;
    // obj.publicVar = 1; // Недоступен, так как publicVar теперь защищенный
    return 0;
}
```

3. Private наследование (закрытое наследование).
* Открытые (`public`) члены базового класса становятся закрытыми.
* Защищенные (`protected`) члены базового класса становятся закрытыми.
* Закрытые (`private`) члены базового класса недоступны напрямую.

```C++
class Base
{
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class Derived : private Base
{
public:
    void access()
    {
        publicVar = 1;     // Доступен как закрытый член
        protectedVar = 2;  // Доступен как закрытый член
        // privateVar = 3; // Недоступен
    }
};

int main()
{
    Derived obj;
    // obj.publicVar = 1; // Недоступен, так как publicVar теперь закрытый
    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## ООП, базовые принципы

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции "объектов", которые могут содержать данные и код: данные в виде полей (часто называемых атрибутами или свойствами), и код в виде процедур (часто называемых методами). Основные принципы ООП включают инкапсуляцию, наследование, полиморфизм и абстракцию.

### Примеры
* Инкапсуляция:
Заключается в скрытии внутреннего состояния объекта и предоставлении доступа к нему только через методы. Это позволяет защитить данные от прямого доступа и изменения извне.
```C++
class Person
{
public:
    // Конструктор
    Person(std::string n, int a) : name(n), age(a) {}

    // Методы для доступа к данным
    void setName(std::string n)
    {
	name = n;
    }

    std::string getName() const
    {
	return name;
    }

    void setAge(int a)
    { 
	if (a > 0) {
	    age = a;
	}
    }

    int getAge() const
    {
	return age;
    }

private:
    std::string name;
    int age;
};

int main()
{
    Person person("Alice", 30);
    person.setAge(31);

    std::cout << person.getName() << " is " << person.getAge() << " years old." << std::endl;

    return 0;
}
```

* Наследование:
Позволяет одному классу (производному или подклассу) унаследовать свойства и методы другого класса (базового или суперкласса). Это способствует повторному использованию кода и организации классов в иерархии.
```C++
class Animal
{
public:
    void eat()
    {
        std::cout << "Eating..." << std::endl;
    }
};

class Dog : public Animal
{
public:
    void bark()
    {
        std::cout << "Barking..." << std::endl;
    }
};

int main()
{
    Dog myDog;

    myDog.eat(); // Метод базового класса
    myDog.bark(); // Метод производного класса

    return 0;
}
```

* Полиморфизм:
Позволяет использовать один и тот же интерфейс для разных типов данных. Это может быть реализовано через виртуальные функции, позволяя производным классам переопределять методы базового класса.
```C++
class Shape
{
public:
    virtual void draw() const
    {
        std::cout << "Drawing a shape" << std::endl;
    }
};

class Circle : public Shape
{
public:
    void draw() const override
    {
        std::cout << "Drawing a circle" << std::endl;
    }
};

class Square : public Shape
{
public:
    void draw() const override
    {
        std::cout << "Drawing a square" << std::endl;
    }
};

void displayShape(const Shape& shape)
{
    shape.draw();
}

int main()
{
    Circle circle;
    Square square;

    displayShape(circle); // Вызовет Circle::draw
    displayShape(square); // Вызовет Square::draw

    return 0;
}
```

* Абстракция:
Заключается в создании упрощенной модели реальности путем выделения наиболее значимых характеристик и поведения, скрывая при этом сложные детали реализации. Это позволяет работать с концепциями и моделями вместо конкретных реализаций.
```C++
class AbstractDevice
{
public:
    virtual void start() = 0; // Чисто виртуальная функция
    virtual void stop() = 0;  // Чисто виртуальная функция
    virtual ~AbstractDevice() = default; // Виртуальный деструктор
};

class Printer : public AbstractDevice
{
public:
    void start() override
    {
        std::cout << "Printer starting..." << std::endl;
    }

    void stop() override
    {
        std::cout << "Printer stopping..." << std::endl;
    }
};

int main()
{
    Printer printer;

    printer.start();
    printer.stop();

    return 0;
}
```
<hr style="width:25%;text-align:left;margin-left:0">

## Оператор "доступ к члену через указатель"

Оператор "доступ к члену через указатель" `->` используется для доступа к членам (данным и методам) объекта через указатель на этот объект. Он сочетает в себе разыменование указателя и доступ к члену объекта.

### Примеры
```C++
class MyClass
{
public:
    int data;
    void show() const
    {
        std::cout << "Data: " << data << std::endl;
    }
};

int main()
{
    MyClass obj;
    obj.data = 42;

    MyClass* ptr = &obj; // Указатель на объект

    ptr->data = 100;     // Доступ к члену данных через указатель
    ptr->show();         // Вызов метода через указатель

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Оператор "запятая"

Оператор запятая `,`, также известный как оператор последовательности, используется для вычисления двух выражений и возвращения значения второго. Оператор запятая имеет очень низкий приоритет, поэтому он часто используется в контексте циклов, выражений и вызовов функций.

### Примеры
* Основной синтаксис и поведение:
```C++
int main()
{
    int x = 10;
    int y = (x + 1, x + 2); // Сначала вычисляется x + 1, затем x + 2, и результат второго выражения присваивается y

    std::cout << "y: " << y << std::endl; // Выводит "y: 12"
    return 0;
}
```

* Использование в циклах:
```C++
int main()
{
    for (int i = 0, j = 10; i < j; ++i, --j) {
        std::cout << "i: " << i << ", j: " << j << std::endl;
    }

    return 0;
}
```

* Использование в выражениях:
```C++
int main()
{
    int a = 0;
    int b = (a = 5, a + 10); // Сначала a присваивается значение 5, затем вычисляется выражение a + 10

    std::cout << "b: " << b << std::endl; // Выводит "b: 15"
    return 0;
}
```

### Особенности и ограничения
* Оператор запятая имеет самый низкий приоритет среди всех операторов в C++, поэтому выражения, разделенные запятыми, вычисляются в строгой последовательности слева направо.
* Оператор запятая может быть полезен в макросах для объединения нескольких операций в одну:
```C++
#define MULTIPLY(a, b) ((a) * (b))

int main()
{
    int result = (MULTIPLY(2 + 3, 3 + 4), 100);
    std::cout << "result: " << result << std::endl; // Выводит "result: 100"
    return 0;
}
```

* Использование оператора запятая может сделать код менее читаемым. Поэтому его следует использовать с осторожностью и только в тех случаях, когда это действительно необходимо.

<hr style="width:25%;text-align:left;margin-left:0">

## Оператор "приведение к типу"

Оператор приведения к типу `()` позволяет выполнить явное преобразование к другому типу. Можно определять для пользовательских типов: `operator typename ()`.

### Примеры
```C++
class Example
{
public:
    Example(std::string name)
     : name_(name)
    {
    }

    operator const char* () // Оператор приведения класса Example к типу const char*
    {
	return name_.c_str();
    }
	
private:
	std::string name_;
};

int main()
{
    double a 5.3;
    int b = (int)(a); // Приведение встроенных типов
	
    Example c("example");
    std::cout << (const char*)(c) << '\n'; // Приведение пользовательского типа
    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Оператор "разыменование"

Оператор разыменование позволяет получить доступ к объекту, на который указывает указатель для чтения или изменения значения.

### Примеры
```C++
int main()
{
    int a = 10;
    int* ptr = &a;
    std::cout << *ptr << '\n';
    *ptr = 4;
    std::cout << *ptr << '\n';
}
//Вывод:
//10
//4
```

<hr style="width:25%;text-align:left;margin-left:0">

## Оператор присваивания перемещающий

Оператор присваивания пермещающий - перегрузка оператора присваивания, который в качестве аргумента принимает rvalue ссылку на тип. Использует семантику перемещения для присваивания значения.

### Примеры
```C++
class Example
{
public:
    Example& operator=(const Example& value)
    {
	if ( *this == value ) return *this;
	data_ = value.data_;
	return *this;
    }

    Example& operator=(Example&& value)
    {
	if ( *this == value ) return *this;
	std::swap(copy.data_, data_);
	copy.data_.Clear(); 
	return *this;
    }
	
private:
	std::vector data_;
};

int main()
{
    Example arr1;
    //....
    Example arr2;
    arr2 = arr1; // Вызывается обычный оператор присваивания
    Example arr3;
    arr3 = std::move(arr1); // Вызывается перемещающий оператор присваивания
    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Перемещение

Перемещение - передача ресурсов от одного объекта путем передачи управления над этими ресурсами. Используется в тех случаях, когда не требуется сохранять состояния объекта, из которого берем значение, чтобы избежать копирования. Для перемещения типу необходимо иметь перемещающий конструктор и перемещающий оператор присваивания. Чтобы вызвать перемещающий вариант конструктора/оператора присваивания используется функция std::move(), которая возвращает rvalue ссылку(правую ссылку) на объект.

### Примеры
```C++
class Example
{
public:
    //....
    Example(Example&& copy)
    {
	std::swap(copy.data_, data_); 
    }
	
    Example& operator=(Example&& value)
    {
	if ( *this == value ) return *this;
	std::swap(copy.data_, data_);
	copy.data_.Clear(); 
    }
	
private:
	std::vector data_;
};

int main()
{
    Example arr1;
    //....
    Example arr2(std::move(arr1)); // После этой операции arr1 будет пустым,а arr2 будет содержать значения arr1 до операции
    Example arr3;
    arr3 = std::move(arr2); // Аналогично операции выше
    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Подстановочный критерий

Подстановочный критерий - производный класс должен обеспечивать интерфейс и контракт родительского класса, т.е. функция, которая работает с базовым классом, должна иметь возможность работать с производным классом, не зная об этом.

### Примеры
```C++
class Base
{
public:
    int Add(double item)
    {
	//... добавление элемента
	if(fail){
		return -1;
	}
	return index;
    }
    // Функция должна возвращать индекс только что добавленного элемента или -1 при ошибке при добавлении
};

class Derived : public Base
{
public:
    int Add(double item) override 
    {
	//... добавление элемента
	return -1;
    }
    // Критерий подстановки не выполняется, так как функция возвращает -1 даже при успешной вставке элемента, хотя должна возвращать индекс элемента
};
```

<hr style="width:25%;text-align:left;margin-left:0">

## Выравнивание

Выравнивание - добавление компилятором незначащий байтов для выравнивания размера типа(структуры) до числа, кратного заданному. Обычно кратно 4, так как чаще всего машинное слово имеет размер 4 байта.

### Примеры
```C++
struct A
{
    char a; // 1 байт
    // 3 незначащих байта
    int b; // 4
    char c; // 1
    // 3 незначащих байта
};
// размер 12 байтов

struct B
{
    char a; // 1 
    char b; // 1
    // 2 незначащих байта
    int c; // 4
};
// размер 8 байтов
```

### Alignas и alignof

Спецификатор `alignas` позволяет вручную задать размер выравнивания для типа. Если размер выравнивания меньше, чем необходимо для хранения типа, то поведение неопределено.

Оператор `alignof` возвращает выравнивание типа в байтах.

### Примеры
```C++
struct A
{
    int a; // 4 байта
    int b; // 4 байта
    int c; // 4 байта
}
// размер 12 байтов

struct alignas(16) B
{
    int a; // 4 байта
    int b; // 4 байта
    int c; // 4 байта
    // 4 байта для выравнивания
}
// размер 16 байтов

int main()
{
    std::cout << alignof(A) << ' ' << alignof(B) << '\n';
    return 0;
};
// Вывод:
// 12 16
```

<hr style="width:25%;text-align:left;margin-left:0">

## Предупреждения

Предупреждения (warnings) компилятора помогают выявлять потенциальные проблемы в коде, такие как ошибки времени выполнения, неиспользуемые переменные, возможные утечки памяти и другие ситуации, которые могут привести к нежелательному поведению программы. Предупреждения позволяют программисту заранее исправить эти проблемы. 

### Примеры
* Неиспользуемая переменная:
```C++
int main()
{
    int x = 10; // Предупреждение: переменная x не используется
    return 0;
}
```

* Несовпадение типов:
```C++
int main()
{
    int x = 10;
    double y = x; // Предупреждение: неявное преобразование int в double
    return 0;
}
``` 

* Неразрешенные возвращаемые значения функций:
```C++
int foo()
{
    return 42;
}

int main()
{
    foo(); // Предупреждение: возвращаемое значение функции foo() не используется
    return 0;
}
```

* Потенциально некорректное использование указателей:
```C++
int main()
{
    int* p = nullptr;
    *p = 42; // Предупреждение: разыменование нулевого указателя
    return 0;
}
```

* Использование устаревших функций:
```C++
#include <stdio.h>

int main()
{
    gets(nullptr); // Предупреждение: функция gets() устарела и небезопасна
    return 0;
}
```

### Управление предупреждениями

Управление предупреждениями:

* В некоторых компиляторах можно настроить уровень предупреждений.
* Можно подавлять отдельные предупреждения.
* Использование атрибутов в C++.

### Примеры
```C++
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4996) // Подавление предупреждения для устаревшей функции
#endif

#include <stdio.h>

int main()
{
	gets(nullptr); // Предупреждение подавлено
    return 0;
}

#ifdef _MSC_VER
#pragma warning(pop)
#endif

// --------------------------------------------------------------------

[[maybe_unused]] int unusedVariable = 10; // Подавление предупреждения о неиспользуемой переменной
```

<hr style="width:25%;text-align:left;margin-left:0">

## Преобразование повышающее

Повышающее преобразование (upcasting) — это процесс приведения указателя или ссылки на объект производного класса к указателю или ссылке на базовый класс. Повышающее преобразование всегда безопасно и выполняется неявно, поскольку объект производного класса всегда является объектом базового класса.

### Примеры
```C++
class Base
{
public:
    virtual void show() const
    {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base
{
public:
    void show() const override
    {
        std::cout << "Derived class" << std::endl;
    }
};

void print(const Base& base)
{
    base.show();
}

Derived derivedObj;
Base* basePtr = &derivedObj; // Повышающее преобразование
Base& baseRef = derivedObj;  // Повышающее преобразование

basePtr->show(); // Вызов виртуальной функции через указатель на базовый класс
baseRef.show();  // Вызов виртуальной функции через ссылку на базовый класс

print(derivedObj); // Передача объекта производного класса в функцию, принимающую ссылку на базовый класс
```

<hr style="width:25%;text-align:left;margin-left:0">

## Преобразование понижающее

Понижающее преобразование (downcasting) в — это приведение указателя или ссылки на базовый класс к указателю или ссылке на производный класс. В отличие от повышающего преобразования (upcasting), которое всегда безопасно и автоматически, понижающее преобразование может быть небезопасным, так как компилятор не может гарантировать, что указатель или ссылка на базовый класс действительно указывают на объект производного класса.

Для выполнения понижающего преобразования можно использовать `dynamic_cast<>`, который выполняет проверку типа во время выполнения (runtime check). 

### Примеры
```C++
class Base
{
public:
    virtual ~Base() = default;

    virtual void show() const
    {
        std::cout << "Base class" << std::endl;
    }
};

class Derived : public Base
{
public:
    void show() const override
    {
        std::cout << "Derived class" << std::endl;
    }

    void specificMethod() const
    {
        std::cout << "Specific method of Derived class" << std::endl;
    }
};

void process(Base* basePtr)
{
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr) {
        derivedPtr->specificMethod();
    } else {
        std::cout << "BasePtr is not pointing to a Derived object." << std::endl;
    }
}

std::unique_ptr<Base> basePtr1 = std::make_unique<Derived>();  // Указатель на производный объект
std::unique_ptr<Base> basePtr2 = std::make_unique<Base>();     // Указатель на базовый объект

process(basePtr1.get());  // Ожидаем успешное преобразование
process(basePtr2.get());  // Ожидаем неудачное преобразование
```

<hr style="width:25%;text-align:left;margin-left:0">


## Приведение типа bit_cast<>

`bit_cast<>` - это функция, представленная в стандарте C++20, которая позволяет безопасно преобразовывать одни биты данных в другие без изменения их значения или представления. Она полезна для операций с бинарными данными, такими как преобразование между числовыми типами и структурами, когда требуется строгое копирование битов. 

### Примеры
```C++
//Преобразование между числовыми типами:
float f = 3.14;
int i = std::bit_cast<int>(f); 

// --------------------------------------

//Преобразование между структурами:
struct Point
{
    float x;
    float y;
};

struct PackedPoint
{
    long long packedData;
};

Point pt = { 1.5f, 2.5f };
PackedPoint packedPt = std::bit_cast<PackedPoint>(pt);
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа const_cast<>

Позволяет убрать/добавить модификатор const с типа(преобразовывать `const` тип в обычный тип и обратно). 

### Примеры
```C++
const int num = 10;
int& numRef = const_cast<int&>(num);
numRef = 20; // Разрешено, но не рекомендуется

// -----------------------------------------

int value = 100;
const int* ptr = &value;
int* ptrMutable = const_cast<int*>(ptr);
*ptrMutable = 200; // Разрешено

// -----------------------------------------

class MyClass
{
public:
    void func() { std::cout << "Non-const func" << std::endl; }
    void func() const { std::cout << "Const func" << std::endl; }
};

const MyClass obj;
const_cast<MyClass&>(obj).func(); // Вызывает неконстантную версию func() 
const_cast<const MyClass&>(obj).func(); // Вызывает константную версию func() 
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа dynamic_cast<>

Оператор `dynamic_cast<>` предназначен для выполнения безопасного приведения типов в иерархиях наследования с использованием полиморфизма. Он позволяет проверить тип объекта во время выполнения и выполнить приведение указателей или ссылок к типу, производному от базового класса. Важно отметить, что dynamic_cast<> работает только с классами, имеющими хотя бы один виртуальный метод.
Основные случаи использования `dynamic_cast<>`:
* Приведение указателей или ссылок на производные классы
* Приведение указателей с использованием полиморфных типов
* Приведение ссылок

### Примеры
```C++
class Base
{
public:
    virtual ~Base() = default;
};

class Derived : public Base
{
public:
    void specificMethod() {}
};

void process(Base* basePtr)
{
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr) {
        derivedPtr->specificMethod();
    } else {
        std::cout << "Не удалось привести тип к Derived" << std::endl;
    }
}

void someFunction(Base& baseRef)
{
    try {
        Derived& derivedRef = dynamic_cast<Derived&>(baseRef);
        // Успешное приведение типа
        derivedRef.specificMethod();
    } catch (std::bad_cast& e) {
        // Не удалось привести тип
        std::cout << "Не удалось привести тип к Derived: " << e.what() << std::endl;
    }
}

int main()
{
    Base* basePtr = new Derived();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); //Приведение указателя на родительский класс к указателю на класс наследник

    if (derivedPtr) {
        // Успешное приведение типа
        derivedPtr->specificMethod();
    } else {
        // Не удалось привести тип
        std::cout << "Не удалось привести тип к Derived" << std::endl;
    }
	
// -------------------------------------------------
	
    Base basePtr = new Derived();
    process(basePtr); // Приведение указателя
	
    // -------------------------------------------------
	
    Base basePtr();
    someFunction(basePtr); //Приведение ссылок
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа reinterpret_cast<>

Оператор `reinterpret_cast<>` используется для выполнения принудительного преобразования одного типа указателя или ссылки в другой тип. Этот оператор позволяет интерпретировать битовую последовательность одного объекта как битовую последовательность другого объекта любого типа. Однако его использование требует особой осторожности, так как `reinterpret_cast<>` не выполняет проверок типов и может привести к непредсказуемому поведению программы, если преобразование неверно использовано.
Основные случаи использования `reinterpret_cast<>`:
* Преобразование указателей и ссылок
* Преобразование между указателями на классы
* Преобразование между указателями и целочисленными типами

### Примеры
```C++
int* intptr = new int(10);
double* doubleptr = reinterpret_cast<double>(intptr); // Преобразование указателя int в double*

// ---------------------------------

class Base
{
    // ...
};

class Derived : public Base
{
    // ...
};

Base* baseptr = new Base();
Derived* derivedptr = reinterpret_cast<Derived>(baseptr); // Преобразование указателя на базовый класс к указателю на производный класс

// ---------------------------------

void ptr = nullptr;
uintptr_t addr = reinterpret_cast<uintptr_t>(ptr); // Преобразование указателя в целочисленный тип
```

<hr style="width:25%;text-align:left;margin-left:0">

## Приведение типа static_cast<>

Оператор `static_cast<>` используется для выполнения явного приведения типов во время компиляции. Он позволяет преобразовывать значения одного типа в другой, когда такое преобразование является безопасным и известным на этапе компиляции.
Вот основные случаи использования `static_cast<>`:
* Преобразование числовых типов
* Преобразование указателей
* Преобразование ссылок
* Преобразование между перечислимыми типами и их значениями

### Примеры
```C++
double a = 4.3;
int b = std::static_cast<int>(a);

// --------------------------------------------

Base* basePtr = new Derived();
Derived* derivedPtr = static_cast<Derived*>(basePtr); // Преобразование указателя на базовый класс к указателю на производный класс

// --------------------------------------------

int i = 10;
double& dRef = static_cast<double&>(i); // Преобразование ссылки int& к double&

// --------------------------------------------

enum class Color { Red, Green, Blue };
int colorValue = static_cast<int>(Color::Green); // Преобразование значения перечислимого типа в int
```

<hr style="width:25%;text-align:left;margin-left:0">

## Производные объекты, конструирование и уничтожение

В C++ производные объекты (derived objects) относятся к объектам, которые наследуют свойства и методы от базовых классов. Конструирование и уничтожение производных объектов являются важными аспектами, которые определяют, как происходит инициализация и освобождение ресурсов во время жизненного цикла объектов. Давайте рассмотрим эти аспекты более подробно.

Конструирование производных объектов
При конструировании производного объекта происходит следующее:

Конструктор базового класса: Сначала вызывается конструктор базового класса. Это происходит в порядке иерархии наследования от верхнего базового класса до непосредственного родителя производного класса.

Конструктор производного класса: После инициализации базового класса вызывается конструктор производного класса. В этом конструкторе происходит инициализация собственных полей производного класса.

Уничтожение производных объектов
При уничтожении производного объекта происходит следующее:

Деструктор производного класса: Сначала вызывается деструктор производного класса. В деструкторе производного класса освобождаются ресурсы, выделенные для его полей.

Деструктор базового класса: После выполнения деструктора производного класса вызывается деструктор базового класса. Это происходит в обратном порядке от производного класса к базовым классам.

В родительском классе деструктор должен быть виртуальный, чтобы при удалении родительского класса, полученного путем повышающего преобразования не происходила утечка памяти.

### Примеры
```C++
// Базовый класс
class Base
{
public:
    Base()
    {
        std::cout << "Конструктор Base" << std::endl;
    }

    virtual ~Base()
    {
        std::cout << "Деструктор Base" << std::endl;
    }
};

// Производный класс
class Derived : public Base
{
public:
    Derived()
    {
        std::cout << "Конструктор Derived" << std::endl;
    }

    ~Derived()
    {
        std::cout << "Деструктор Derived" << std::endl;
    }
};

int main()
{
    Derived d; // Создание производного объекта
    return 0;
}
//Вывод:
//Конструктор Base
//Конструктор Derived
//Деструктор Derived
//Деструктор Base
```

<hr style="width:25%;text-align:left;margin-left:0">

## Прямая передача

Прямая передача - передача аргументов без лишнего копирования/перемещения. Используется в обёрточных функциях для передачи аргументов. Реализуется при помощи функции `std::forward<T>`, которая передает значение сохраняя его тип(lvalue/rvalue). 

### Примеры
```C++
#include <utility> // Для std::forward

// Функция process для обработки строки rvalue
void process(std::string&& str)
{
    std::cout << "Обработка rvalue строки: " << str << std::endl;
}

// Функция process для обработки строки lvalue
void process(const std::string& str)
{
    std::cout << "Обработка lvalue строки: " << str << std::endl;
}

// Шаблонная функция wrapper с универсальной ссылкой
template <typename T>
void wrapper(T&& arg)
{
    // Передаем аргумент в функцию process с помощью std::forward,
    // чтобы сохранить его тип (lvalue или rvalue)
    process(std::forward<T>(arg));
}

int main()
{
    std::string s = "Hello";
    wrapper(s);            // Вызов с lvalue
    wrapper(std::move(s)); // Вызов с rvalue

    return 0;
}
```

<hr style="width:25%;text-align:left;margin-left:0">

## Ссылка (правая)

Правая ссылка(rvalue) - ссылка на временный объект. Используется для избежания ненужного копирования(семантика перемещения), так как позволяет перемещать ресурсы одного объекта в другой.

### Примеры
```C++
std::string str1 = "Hello, World!";
std::cout << "str1: " << str1 << std::endl;

// Перемещаем содержимое str1 в str2
std::string str2 = std::move(str1);
std::cout << "После перемещения:" << std::endl;
std::cout << "str1: " << str1 << std::endl;
std::cout << "str2: " << str2 << std::endl;

//Вывод:
//str1: Hello, World!
//После перемещения:
//str1: 
//str2: Hello, World!
```

<hr style="width:25%;text-align:left;margin-left:0">

## Шаблон, специализация

Шаблон - это конструкция, которая на этапе компиляции создает обычный тип или функцию на основе аргументов. Используется в качестве альтернативы многочисленным перегрузкам, когда поведение функции для многочисленного набора разных типов одинаково или похоже.

Специализация - определение функций или типов для специального набора аргументов.

### Примеры
```C++
// Объявление шаблона функции
template <typename T>
T add(T a, T b)
{
    return a + b;
}

//специализация шаблона функции
template <>
std::string add<std::string>(std::string a, std::string b)
{
    return a.append(b);
}

// Объявление шаблона класса
template <typename T>
class Box
{
public:
    Box(T v) : value(v) {}

private:
    T value;
};
```

<hr style="width:25%;text-align:left;margin-left:0">

<p align="right">(<a href="#readme-top">Вернуться в начало</a>)</p>
